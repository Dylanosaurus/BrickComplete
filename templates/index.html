{% extends "base.html" %}

{% block title %}BrickComplete - LEGO Set Inventory Manager{% endblock %}

{% block content %}
<style>
.instance-description-container {
    margin-top: 10px;
}

.instance-description {
    padding: 8px 12px;
    border: 1px solid #e9ecef;
    border-radius: 4px;
    background-color: #f8f9fa;
    cursor: pointer;
    transition: all 0.2s ease;
    min-height: 38px;
    display: flex;
    align-items: center;
}

.instance-description:hover {
    background-color: #e9ecef;
    border-color: #dee2e6;
}

.instance-description-input {
    border: 2px solid #007bff;
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

.instance-description.has-content {
    background-color: #fff;
    border-color: #28a745;
}

.instance-description.has-content:hover {
    background-color: #f8f9fa;
}

.auto-save-indicator {
    position: fixed;
    top: 20px;
    right: 20px;
    background-color: #28a745;
    color: white;
    padding: 8px 16px;
    border-radius: 4px;
    font-size: 14px;
    z-index: 1050;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    transition: opacity 0.3s ease;
    display: none;
    opacity: 0;
}

.auto-save-indicator i {
    margin-right: 5px;
}

/* Grid layout for parts */
.parts-grid {
    display: grid;
    gap: 1rem;
    grid-template-columns: repeat(2, 1fr);
}

.parts-grid.cols-1 {
    grid-template-columns: repeat(1, 1fr);
}

.parts-grid.cols-2 {
    grid-template-columns: repeat(2, 1fr);
}

.parts-grid.cols-3 {
    grid-template-columns: repeat(3, 1fr);
}

.parts-grid.cols-4 {
    grid-template-columns: repeat(4, 1fr);
}

.parts-grid.cols-5 {
    grid-template-columns: repeat(5, 1fr);
}

.parts-grid.cols-6 {
    grid-template-columns: repeat(6, 1fr);
}

.parts-grid.cols-7 {
    grid-template-columns: repeat(7, 1fr);
}

.parts-grid.cols-8 {
    grid-template-columns: repeat(8, 1fr);
}

.parts-grid.cols-9 {
    grid-template-columns: repeat(9, 1fr);
}

.parts-grid.cols-10 {
    grid-template-columns: repeat(10, 1fr);
}

/* Responsive adjustments for smaller screens */
@media (max-width: 768px) {
    .parts-grid.cols-4,
    .parts-grid.cols-5,
    .parts-grid.cols-6,
    .parts-grid.cols-7,
    .parts-grid.cols-8,
    .parts-grid.cols-9,
    .parts-grid.cols-10 {
        grid-template-columns: repeat(2, 1fr);
    }
}

@media (max-width: 576px) {
    .parts-grid.cols-3,
    .parts-grid.cols-4,
    .parts-grid.cols-5,
    .parts-grid.cols-6,
    .parts-grid.cols-7,
    .parts-grid.cols-8,
    .parts-grid.cols-9,
    .parts-grid.cols-10 {
        grid-template-columns: repeat(1, 1fr);
    }
}

/* Part image styling */
.part-image {
    width: 80px;
    height: 80px;
    object-fit: contain;
    border-radius: 4px;
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
}

.part-image-container {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 80px;
}

/* Center quantity controls */
.quantity-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 0.5rem;
}

/* Instance status styling */
.instance-status {
    flex-shrink: 0;
}

.status-badge {
    padding: 0.25rem 0.5rem;
    border-radius: 0.375rem;
    font-size: 0.875rem;
    font-weight: 500;
}

.status-complete {
    background-color: #d1edff;
    color: #0c5460;
    border: 1px solid #b8daff;
}

.status-missing {
    background-color: #f8d7da;
    color: #721c24;
    border: 1px solid #f5c6cb;
}

.status-extra {
    background-color: #d4edda;
    color: #155724;
    border: 1px solid #c3e6cb;
}


.instance-status-detailed {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.status-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.25rem 0;
    border-bottom: 1px solid #e9ecef;
}

.status-item:last-child {
    border-bottom: none;
}

.status-label {
    font-weight: 500;
    color: #6c757d;
}

.status-value {
    font-weight: 600;
}
</style>
<div class="row">
    <div class="col-12">
        <div class="jumbotron bg-light p-5 rounded mb-4">
            <h1 class="display-4">
                <i class="fas fa-cube text-danger"></i> BrickComplete
            </h1>
            <p class="lead">Search for LEGO sets and manage your inventory with ease!</p>
            <hr class="my-4">
            <p>Enter a LEGO set number to view its inventory and modify quantities for your collection.</p>
        </div>
    </div>
</div>

<div class="row">
    <div class="col-md-6">
        <div class="card">
            <div class="card-header">
                <h5><i class="fas fa-search"></i> Search LEGO Set</h5>
            </div>
            <div class="card-body">
                <form id="searchForm" autocomplete="off">
                    <div class="mb-3">
                        <label for="setNumber" class="form-label">Set Number</label>
                        <input type="text" class="form-control" id="setNumber" placeholder="e.g., 10265-1" autocomplete="off" required>
                        <div class="form-text">Enter the LEGO set number (format: 10265-1)</div>
                        <div id="setSuggestions" class="mt-2" style="display: none;">
                            <small class="text-muted">Suggestions:</small>
                            <div id="suggestionList" class="mt-1"></div>
                        </div>
                    </div>
                    <button type="submit" class="btn btn-lego">
                        <i class="fas fa-search"></i> Search Set
                    </button>
                </form>
            </div>
        </div>
    </div>
    
    <div class="col-md-6">
        <div class="card" id="howItWorks">
            <div class="card-header">
                <h5><i class="fas fa-info-circle"></i> How it Works</h5>
            </div>
            <div class="card-body">
                <ol>
                    <li>Enter a LEGO set number in the search box</li>
                    <li>View the complete inventory of parts</li>
                    <li>Use + and - buttons to modify quantities</li>
                    <li>Your changes are automatically saved to your account</li>
                </ol>
                {% if not current_user.is_authenticated %}
                <div class="alert alert-warning mt-3">
                    <i class="fas fa-exclamation-triangle"></i>
                    <strong>Login required!</strong> You need to be logged in to save inventory modifications.
                </div>
                {% endif %}
            </div>
        </div>
        <div class="card" id="setInfo" style="display: none;">
            <div class="card-header d-flex justify-content-between align-items-center" style="height: 80px;">
                  <h5 id="setTitle"><i class="fas fa-cube"></i> Set Information</h5>
                  <div class="d-flex flex-column align-items-end gap-2">
                      <button id="legoInstructionsBtn" class="btn btn-outline-primary" onclick="openLegoInstructions()" style="display: none;">
                          <i class="fas fa-external-link-alt"></i> Lego Instructions
                      </button>
                      <button id="buildingInstructionsBtn" class="btn btn-outline-info" onclick="openBuildingInstructions()" style="display: none;">
                          <i class="fas fa-book"></i> BrickInstructions
                      </button>
                    <button class="btn btn-success" id="saveInventory" style="display: none;">
                        <i class="fas fa-save"></i> Save Changes
                    </button>
                </div>
            </div>
            <div class="card-body" style="height: 404px;">
                <div id="setDetails"></div>
            </div>
        </div>
    </div>
</div>



<div id="instanceSelectionSection" class="row mt-4" style="display: none;">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <h5><i class="fas fa-list"></i> Select Set Instance</h5>
            </div>
            <div class="card-body">
                <p class="text-muted" id="instanceSelectionText">You have existing instances of this set. Choose which one to view or add a new instance:</p>
                <div id="instanceSelectionList" class="mb-3"></div>
                <div class="row">
                    <div class="col-md-8">
                        <div class="input-group">
                            <span class="input-group-text"><i class="fas fa-tag"></i></span>
                            <input type="text" class="form-control" id="newInstanceName" placeholder="Enter new instance name (e.g., 'Built Set', 'Spare Parts')" value="Default" autocomplete="off">
                        </div>
                        <div class="form-text">Give this new set instance a unique name</div>
                    </div>
                    <div class="col-md-4">
                        <button class="btn btn-success w-100" id="addNewInstanceBtn" onclick="addNewInstance()">
                            <i class="fas fa-plus"></i> Add New Instance
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="inventoryContainer" class="row mt-4" style="display: none;">
    <div class="col-12">
        <!-- Instance Info Card -->
        <div class="card mb-4">
            <div class="card-header">
                <h5><i class="fas fa-info-circle"></i> Instance Info</h5>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label class="form-label fw-bold">Description:</label>
                            <div id="instanceDescription" class="instance-description" onclick="editDescription()" title="Click to edit description">
                                <i class="fas fa-edit text-muted me-2"></i>
                                <span id="descriptionText">Click to add a description for this set instance...</span>
                            </div>
                            <input type="text" id="descriptionInput" class="form-control instance-description-input" 
                                   placeholder="Enter description for this set instance..." 
                                   style="display: none;" 
                                   onblur="saveDescription()" 
                                   onkeypress="handleDescriptionKeyPress(event)">
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label class="form-label fw-bold">Status:</label>
                            <div id="instanceStatusDetailed" class="instance-status-detailed">
                                <!-- Detailed status will be populated by JavaScript -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Set Inventory Card -->
        <div class="card">
            <div class="card-header">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h5><i class="fas fa-list"></i> Set Inventory</h5>
                </div>
            </div>
            <div id="colorFilterPanel" class="card-body" style="border-bottom: 1px solid #dee2e6;">
                <!-- Color Filter Row -->
                <div class="row mb-3">
                    <div class="col-12">
                <h6 class="mb-3"><i class="fas fa-palette"></i> Filter by Color</h6>
                <div id="colorFilterButtons" class="d-flex flex-wrap gap-2">
                    <!-- Color filter buttons will be dynamically generated here -->
                </div>
                    </div>
                </div>
                
                <!-- Modification and Category Filter Row -->
                <div class="d-flex align-items-center gap-4">
                    <div class="d-flex flex-column">
                        <h6 class="mb-2"><i class="fas fa-filter"></i> Filter by Modification</h6>
                        <div class="btn-group" role="group" aria-label="Modification filter">
                            <button type="button" class="btn btn-sm btn-outline-primary modification-filter-btn active" 
                                    data-filter="all" onclick="setModificationFilter('all')">
                                <i class="fas fa-list"></i> All
                            </button>
                            <button type="button" class="btn btn-sm btn-outline-danger modification-filter-btn" 
                                    data-filter="missing" onclick="setModificationFilter('missing')">
                                <i class="fas fa-minus-circle"></i> Missing
                            </button>
                            <button type="button" class="btn btn-sm btn-outline-success modification-filter-btn" 
                                    data-filter="extra" onclick="setModificationFilter('extra')">
                                <i class="fas fa-plus-circle"></i> Extra
                            </button>
                        </div>
                    </div>
                    
                    <!-- Vertical Separator -->
                    <div class="vr"></div>
                    
                    <div class="d-flex flex-column">
                        <h6 class="mb-2"><i class="fas fa-tags"></i> Filter by Category</h6>
                        <div class="btn-group" role="group" aria-label="Category filter">
                            <button type="button" class="btn btn-sm btn-outline-primary category-filter-btn active" 
                                    data-filter="all" onclick="setCategoryFilter('all')">
                                <i class="fas fa-list"></i> All
                            </button>
                            <button type="button" class="btn btn-sm btn-outline-info category-filter-btn" 
                                    data-filter="regular" onclick="setCategoryFilter('regular')">
                                <i class="fas fa-cube"></i> Regular
                            </button>
                            <button type="button" class="btn btn-sm btn-outline-warning category-filter-btn" 
                                    data-filter="minifig" onclick="setCategoryFilter('minifig')">
                                <i class="fas fa-user"></i> Minifig
                            </button>
                            <button type="button" class="btn btn-sm btn-outline-secondary category-filter-btn" 
                                    data-filter="spare" onclick="setCategoryFilter('spare')">
                                <i class="fas fa-gift"></i> Spare
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="mt-3 d-flex justify-content-start align-items-center">
                    <button id="clearAllFiltersBtn" class="btn btn-sm btn-outline-secondary" onclick="clearAllFilters()" style="display: none;">
                        <i class="fas fa-times"></i> Clear All Filters
                    </button>
                </div>
            </div>
            <div class="card-body">
                <div id="inventoryList"></div>
            </div>
        </div>
    </div>
</div>

<div id="loadingSpinner" class="text-center mt-4" style="display: none;">
    <div class="spinner-border text-danger" role="status">
        <span class="visually-hidden">Loading...</span>
    </div>
    <p class="mt-2">Loading set information...</p>
</div>

<!-- Instruction Images Modal -->
<div class="modal fade" id="instructionModal" tabindex="-1" aria-labelledby="instructionModalLabel">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                       <h5 class="modal-title" id="instructionModalLabel">
                           <i class="fas fa-book"></i> BrickInstructions
                       </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div id="instructionImages" class="text-center">
                    <!-- Instruction images will be loaded here -->
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="{{ url_for('static', filename='js/common.js') }}"></script>
<script>
let modifiedInventory = {};
let currentInstanceName = 'Default';
// hasUnsavedChanges removed - auto-save is now implemented
let currentlySelectedInstance = null;
let originalInventoryMap = {};

// Recent searches functionality
const RECENT_SEARCHES_KEY = 'brickcomplete_recent_searches';
const MAX_RECENT_SEARCHES = 5;

// Instruction availability cache functionality
const INSTRUCTION_CACHE_KEY = 'brickcomplete_instruction_cache';
const MAX_CACHED_SETS = 20;
let instructionCache = {}; // Global cache variable

function getRecentSearches() {
    try {
        const stored = localStorage.getItem(RECENT_SEARCHES_KEY);
        return stored ? JSON.parse(stored) : [];
    } catch (error) {
        console.error('Error loading recent searches:', error);
        return [];
    }
}

function saveRecentSearches(searches) {
    try {
        localStorage.setItem(RECENT_SEARCHES_KEY, JSON.stringify(searches));
    } catch (error) {
        console.error('Error saving recent searches:', error);
    }
}

function addToRecentSearches(setNumber, setName) {
    const recentSearches = getRecentSearches();
    
    // Remove if already exists
    const existingIndex = recentSearches.findIndex(item => item.setNumber === setNumber);
    if (existingIndex !== -1) {
        recentSearches.splice(existingIndex, 1);
    }
    
    // Add to beginning
    recentSearches.unshift({
        setNumber: setNumber,
        setName: setName,
        timestamp: new Date().toISOString()
    });
    
    // Keep only the most recent searches
    if (recentSearches.length > MAX_RECENT_SEARCHES) {
        recentSearches.splice(MAX_RECENT_SEARCHES);
    }
    
    saveRecentSearches(recentSearches);
    
    // Refresh recent search suggestions
    loadRecentSearchSuggestions();
}

// Instruction availability cache functions
function loadInstructionCache() {
    try {
        const stored = localStorage.getItem(INSTRUCTION_CACHE_KEY);
        instructionCache = stored ? JSON.parse(stored) : {};
    } catch (error) {
        console.error('Error loading instruction cache:', error);
        instructionCache = {};
    }
}

function saveInstructionCache() {
    try {
        localStorage.setItem(INSTRUCTION_CACHE_KEY, JSON.stringify(instructionCache));
    } catch (error) {
        console.error('Error saving instruction cache:', error);
    }
}

function getCachedInstructionAvailability(setNumber) {
    return instructionCache[setNumber] || null;
}

function setCachedInstructionAvailability(setNumber, legoAvailable, brickAvailable) {
    // Add new entry to global cache
    instructionCache[setNumber] = {
        lego: legoAvailable,
        brick: brickAvailable,
        timestamp: Date.now()
    };
    
    // Keep only the most recent entries
    const entries = Object.entries(instructionCache);
    if (entries.length > MAX_CACHED_SETS) {
        // Sort by timestamp and keep only the most recent
        entries.sort((a, b) => b[1].timestamp - a[1].timestamp);
        const recentEntries = entries.slice(0, MAX_CACHED_SETS);
        
        // Rebuild global cache with only recent entries
        const newCache = {};
        recentEntries.forEach(([setNum, data]) => {
            newCache[setNum] = data;
        });
        instructionCache = newCache;
    }
    
    // Save to localStorage
    saveInstructionCache();
}

document.getElementById('searchForm').addEventListener('submit', function(e) {
    e.preventDefault();
    const setNumber = document.getElementById('setNumber').value.trim();
    if (setNumber) {
        searchSet(setNumber);
    }
});

// Add input event listener for set number suggestions
document.getElementById('setNumber').addEventListener('input', function(e) {
    const value = e.target.value.trim();
    showSuggestions(value);
});

// Add focus event listener to show recent searches when input is focused and empty
document.getElementById('setNumber').addEventListener('focus', function(e) {
    const value = e.target.value.trim();
    if (value.length === 0) {
        showSuggestions('');
    }
});

// Add keyboard navigation for set number input
document.getElementById('setNumber').addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
        e.preventDefault();
        // If a suggestion is highlighted, use that; otherwise use the first suggestion if available, or the input value
        let setNumber;
        if (currentSuggestionIndex >= 0 && currentSuggestionIndex < suggestionItems.length) {
            const highlightedItem = suggestionItems[currentSuggestionIndex];
            // Extract set number from the suggestion item
            setNumber = extractSetNumberFromSuggestion(highlightedItem);
        } else if (suggestionItems.length > 0) {
            // Auto-select the first suggestion if no suggestion is highlighted
            setNumber = extractSetNumberFromSuggestion(suggestionItems[0]);
        } else {
            setNumber = e.target.value.trim();
        }
        if (setNumber) {
            searchSet(setNumber);
            // hideSetSuggestions();
        }
    } else if (e.key === 'Escape') {
        hideSetSuggestions();
    } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        navigateSuggestions(1);
    } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        navigateSuggestions(-1);
    }
});

// Add Enter key support for new instance name input
document.getElementById('newInstanceName').addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
        e.preventDefault();
        addNewInstance();
    }
});

// Set suggestions are now fetched from the database

// Global variables for suggestion navigation
let currentSuggestionIndex = -1;
let suggestionItems = [];
let allSuggestions = []; // Store all suggestions (recent + autofill)
let recentSearchSuggestions = []; // Store recent search suggestions
let autofillSuggestions = []; // Store autofill suggestions

// Global variables for instance navigation
let currentInstanceIndex = -1;
let instanceItems = [];
let navigationInstance = false;

function extractSetNumberFromSuggestion(suggestionItem) {
    // For recent search suggestions, extract the set number from the HTML structure
    const setNumberSpan = suggestionItem.querySelector('span');
    if (setNumberSpan) {
        // Remove the icon and get just the set number
        return setNumberSpan.textContent.replace(/^[^\w]*/, '').trim();
    }
    // Fallback to textContent for autofill suggestions
    return suggestionItem.textContent.trim();
}

function createRecentSearchSuggestion(search) {
    const suggestionItem = document.createElement('div');
    suggestionItem.className = 'suggestion-item p-2 border rounded mb-1 cursor-pointer bg-light';
    suggestionItem.style.cursor = 'pointer';
    suggestionItem.id = `suggestion-${search.setNumber}`;
    suggestionItem.innerHTML = `
        <div class="d-flex justify-content-between align-items-center">
            <span><i class="fas fa-history me-2"></i>${search.setNumber}</span>
            <small class="text-muted">${search.setName}</small>
        </div>
    `;
    suggestionItem.addEventListener('click', function() {
        hideSetSuggestions();
        searchSet(search.setNumber);
    });
    return suggestionItem;
}

function createAutofillSuggestion(setData) {
    const suggestionItem = document.createElement('div');
    suggestionItem.className = 'suggestion-item p-2 border rounded mb-1 cursor-pointer bg-light';
    suggestionItem.style.cursor = 'pointer';
    suggestionItem.id = `suggestion-${setData.set_number}`;
    suggestionItem.innerHTML = `
        <div class="d-flex justify-content-between align-items-center">
            <span><i class="fas fa-search me-2"></i>${setData.set_number}</span>
            <small class="text-muted">${setData.set_name}</small>
        </div>
    `;
    suggestionItem.addEventListener('click', function() {
        document.getElementById('setNumber').value = setData.set_number;
        hideSetSuggestions();
        searchSet(setData.set_number);
    });
    return suggestionItem;
}

function loadRecentSearchSuggestions() {
    const recentSearches = getRecentSearches();
    recentSearchSuggestions = recentSearches.map(search => createRecentSearchSuggestion(search));
}

async function loadAutofillSuggestions(query) {
    if (query.length < 2) {
        autofillSuggestions = [];
        return;
    }
    
    try {
        const response = await fetch(`/get_set_suggestions?q=${encodeURIComponent(query)}&limit=10`);
        if (response.ok) {
            const suggestions = await response.json();
            autofillSuggestions = suggestions.map(setData => createAutofillSuggestion(setData));
        } else {
            autofillSuggestions = [];
        }
    } catch (error) {
        console.error('Error fetching autofill suggestions:', error);
        autofillSuggestions = [];
    }
}

function filterAndDisplaySuggestions(input) {
    const suggestionList = document.getElementById('suggestionList');
    const suggestionContainer = document.getElementById('setSuggestions');
    
    // Unhighlight any previously highlighted suggestions
    if (suggestionItems.length > 0) {
        suggestionItems.forEach(item => {
            item.classList.remove('bg-primary', 'text-white');
            item.classList.add('bg-light');
            // Reset set name text color
            const setNameElement = item.querySelector('small');
            if (setNameElement) {
                setNameElement.classList.remove('text-white');
                setNameElement.classList.add('text-muted');
            }
        });
    }
    
    // Clear current display
    suggestionList.innerHTML = '';
    suggestionItems = [];
    currentSuggestionIndex = -1;
    
    let filteredSuggestions = [];
    
    if (input.length === 0) {
        // Show all recent searches when input is empty
        filteredSuggestions = recentSearchSuggestions.slice(0, 5);
    } else {
        // Filter suggestions based on input
        const query = input.toLowerCase();
        
        // Filter recent searches
        const filteredRecent = recentSearchSuggestions.filter(item => {
            const setNumber = item.querySelector('span').textContent.replace(/^[^\w]*/, '').trim();
            return setNumber.toLowerCase().startsWith(query);
        });
        
        // Filter autofill suggestions, excluding those that are already in recent searches
        const recentSetNumbers = new Set(filteredRecent.map(item => {
            return item.querySelector('span').textContent.replace(/^[^\w]*/, '').trim();
        }));
        
        const filteredAutofill = autofillSuggestions.filter(item => {
            const setNumber = item.querySelector('span').textContent.replace(/^[^\w]*/, '').trim();
            return setNumber.toLowerCase().startsWith(query) && !recentSetNumbers.has(setNumber);
        });
        
        // Combine recent searches first (priority), then autofill, limit to 5 total
        filteredSuggestions = [...filteredRecent, ...filteredAutofill].slice(0, 5);
    }
    
    // Display filtered suggestions
    if (filteredSuggestions.length > 0) {
        filteredSuggestions.forEach(suggestion => {
            suggestionList.appendChild(suggestion);
            suggestionItems.push(suggestion);
        });
        suggestionContainer.style.display = 'block';
    } else {
        suggestionContainer.style.display = 'none';
    }
}

function navigateSuggestions(direction) {
    const suggestionContainer = document.getElementById('setSuggestions');
    if (suggestionContainer.style.display === 'none' || suggestionItems.length === 0) {
        return;
    }
    
    // Update the current index
    currentSuggestionIndex += direction;
    
    // Wrap around if needed
    if (currentSuggestionIndex < 0) {
        currentSuggestionIndex = suggestionItems.length - 1;
    } else if (currentSuggestionIndex >= suggestionItems.length) {
        currentSuggestionIndex = 0;
    }
    
    // Remove highlight from all items
    suggestionItems.forEach(item => {
        item.classList.remove('bg-primary', 'text-white');
        item.classList.add('bg-light');
        // Reset set name text color
        const setNameElement = item.querySelector('small');
        if (setNameElement) {
            setNameElement.classList.remove('text-white');
            setNameElement.classList.add('text-muted');
        }
    });
    
    // Highlight the current item
    if (currentSuggestionIndex >= 0 && currentSuggestionIndex < suggestionItems.length) {
        const currentItem = suggestionItems[currentSuggestionIndex];
        currentItem.classList.remove('bg-light');
        currentItem.classList.add('bg-primary', 'text-white');
        
        // Make set name text white when highlighted
        const setNameElement = currentItem.querySelector('small');
        if (setNameElement) {
            setNameElement.classList.remove('text-muted');
            setNameElement.classList.add('text-white');
        }
        
        // Update the input field with just the set number from the selected suggestion
        const setNumberInput = document.getElementById('setNumber');
        setNumberInput.value = extractSetNumberFromSuggestion(currentItem);
    }
}

async function showSuggestions(input) {
    // Load recent search suggestions if not already loaded
    if (recentSearchSuggestions.length === 0) {
        loadRecentSearchSuggestions();
    }
    
    // Load autofill suggestions if user is typing
    if (input.length >= 2) {
        await loadAutofillSuggestions(input);
    } else {
        autofillSuggestions = [];
    }
    
    // Filter and display suggestions
    filterAndDisplaySuggestions(input);
}

function hideSetSuggestions() {
    // document.getElementById('setSuggestions').style.display = 'none';
    // Reset navigation state
    // currentSuggestionIndex = -1;
    // suggestionItems = [];
}

// // Instance navigation functions
// function updateInstanceItems() {
//     const instanceSelectionList = document.getElementById('instanceSelectionList');
//     if (instanceSelectionList) {
//         instanceItems = Array.from(instanceSelectionList.querySelectorAll('div[onclick*="instanceClicked"]'));
//     }
// }

function navigateInstances(direction) {
    if (!navigationInstance) {
        return;
    }
    const instanceSelectionSection = document.getElementById('instanceSelectionSection');
    if (instanceSelectionSection.style.display === 'none' || instanceItems.length === 0) {
        return;
    }
    
    // Update the current index
    currentInstanceIndex += direction;
    
    // Wrap around if needed
    if (currentInstanceIndex < 0) {
        currentInstanceIndex = instanceItems.length - 1;
    } else if (currentInstanceIndex >= instanceItems.length) {
        currentInstanceIndex = 0;
    }
    
    // Call selectInstance with the current instance
    if (currentInstanceIndex >= 0 && currentInstanceIndex < instanceItems.length) {
        const currentItem = instanceItems[currentInstanceIndex].instance_name;
        selectInstance(currentSetNumber, currentItem);
    }
}

function resetInstanceNavigation() {
    // currentInstanceIndex = -1;
    // instanceItems = [];
    navigationInstance = false;
}

// Hide suggestions when clicking outside
document.addEventListener('click', function(e) {
    const setNumberInput = document.getElementById('setNumber');
    const suggestions = document.getElementById('setSuggestions');
    
    if (!setNumberInput.contains(e.target) && !suggestions.contains(e.target)) {
        hideSetSuggestions();
    }
    
    // Reset instance navigation when clicking outside instance selection
    const instanceSelectionSection = document.getElementById('instanceSelectionSection');
    if (instanceSelectionSection && !instanceSelectionSection.contains(e.target)) {
        resetInstanceNavigation();
    }
});

// Global keyboard navigation for instances
document.addEventListener('keydown', function(e) {
    // Only handle arrow keys when instance selection section is visible and has instances
    const instanceSelectionSection = document.getElementById('instanceSelectionSection');
    if (instanceSelectionSection && instanceSelectionSection.style.display !== 'none' && instanceItems.length > 0) {
        if (e.key === 'ArrowUp') {
            e.preventDefault();
            navigateInstances(-1);
        } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            navigateInstances(1);
        }
    }
});

async function searchSet(setNumber) {
    currentSetNumber = setNumber;
    currentlySelectedInstance = null; // Reset selected instance for new search
    
    // Reset filters for new search
    resetAllFiltersForNewSearch();
    
    // Hide previous results and show loading
    document.getElementById('howItWorks').style.display = 'none';
    // document.getElementById('instanceSelectionSection').style.display = 'none';
    document.getElementById('inventoryContainer').style.display = 'none';
    
    // Hide instruction buttons and show loading state
    document.getElementById('buildingInstructionsBtn').style.display = 'none';
    document.getElementById('legoInstructionsBtn').style.display = 'none';
    
    try {
        const response = await fetch('/search_set', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ set_number: setNumber })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            displaySetInfo(data);
            // Add to recent searches
            addToRecentSearches(setNumber, data.set_name);
            // Clear the search bar after successful search
            document.getElementById('setNumber').value = '';
            // showSuggestions('');
            // hideSetSuggestions();
            // Don't load inventory here - let displaySetInfo handle instance selection first
        } else {
            showAlert(data.error || 'Failed to fetch set information', 'danger');
        }
    } catch (error) {
        showAlert('Network error: ' + error.message, 'danger');
    } finally {
    }
}

async function displaySetInfo(data) {
    // First, show basic set info without external calls
    document.getElementById('setTitle').innerHTML = 
        `<i class="fas fa-cube"></i> ${data.set_name}`;
    
    // Create basic set details HTML (without image initially)
    let setDetailsHTML = `
        <div class="row">
            <div class="col-md-6">
                <strong>Set Number:</strong> ${data.set_number}
            </div>
            <div class="col-md-6">
                <strong>Total Parts:</strong> ${data.num_parts || data.inventory.length}
            </div>
        </div>
    `;
    
    // Add year if available
    if (data.year) {
        setDetailsHTML += `
            <div class="row mt-2">
                <div class="col-md-6">
                    <strong>Year:</strong> ${data.year}
                </div>
            </div>
        `;
    }
    
    // Show basic set info immediately
    document.getElementById('setDetails').innerHTML = setDetailsHTML;
    document.getElementById('setInfo').style.display = 'block';
    
    // Load instances first (fast, local database calls)
    instanceItems = await getInstances(data.set_number);
    displayInstances(instanceItems, data.set_number);
    if (instanceItems.length > 0) {
        selectInstance(data.set_number, instanceItems[0].instance_name);
    }
    document.getElementById('instanceSelectionSection').style.display = 'block';
    
    // Load set image and building instructions in the background (slow, external calls)
    loadSetImageAndInstructions(data);
}

async function loadSetImageAndInstructions(data) {
    // Add set image if available
    if (data.set_image) {
        const bricklinkUrl = `https://img.bricklink.com/ItemImage/SN/0/${data.set_number}.png`;
        const imageHTML = data.set_url ? 
            `<a href="${data.set_url}" target="_blank" rel="noopener noreferrer" title="View set on official website">
                <img src="${data.set_image}" 
                     alt="${data.set_name}" 
                     class="img-fluid rounded shadow-sm" 
                     style="max-height: 300px; max-width: 100%; cursor: pointer;"
                     onerror="this.src='${bricklinkUrl}'; this.onerror=function(){this.style.display='none'; this.nextElementSibling.style.display='block';};">
            </a>` :
            `<img src="${data.set_image}" 
                 alt="${data.set_name}" 
                 class="img-fluid rounded shadow-sm" 
                 style="max-height: 300px; max-width: 100%;"
                 onerror="this.src='${bricklinkUrl}'; this.onerror=function(){this.style.display='none'; this.nextElementSibling.style.display='block';};">`;
            
        const imageSection = `
            <div class="row mt-3">
                <div class="col-12 text-center">
                    ${imageHTML}
                </div>
            </div>
        `;
        
        // Append image to existing set details
        document.getElementById('setDetails').innerHTML += imageSection;
    } else {
        // If no set image, try BrickLink directly
        const bricklinkUrl = `https://img.bricklink.com/ItemImage/SN/0/${data.set_number}.png`;
        const imageSection = `
            <div class="row mt-3">
                <div class="col-12 text-center">
                    <img src="${bricklinkUrl}" 
                         alt="${data.set_name}" 
                         class="img-fluid rounded shadow-sm" 
                         style="max-height: 300px; max-width: 100%;"
                         onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                </div>
            </div>
        `;
        
        // Append image to existing set details
        document.getElementById('setDetails').innerHTML += imageSection;
    }
    
    // Check if building instructions exist (slow external call)
    await checkBuildingInstructionsAvailability(data.set_number);
}

function displayInventory(inventory) {
    const container = document.getElementById('inventoryList');
    const colorFilterPanel = document.getElementById('colorFilterPanel');
    container.innerHTML = '';
    
    // Auto-save is now enabled, no need to track unsaved changes
    
    // Don't reset filters when switching instances - preserve user's filter selections
    // selectedColors.clear();
    // currentModificationFilter = 'all';
    // currentCategoryFilter = 'all';
    
    // Check if inventory is empty
    if (!inventory || inventory.length === 0) {
        // Show only the card header and a "no parts" message
        colorFilterPanel.style.display = 'none';
        container.innerHTML = `
            <div class="text-center py-5">
                <i class="fas fa-inbox fa-3x text-muted mb-3"></i>
                <h5 class="text-muted">This set contains no parts</h5>
                <p class="text-muted">No inventory data is available for this set.</p>
            </div>
        `;
        document.getElementById('inventoryContainer').style.display = 'block';
        return;
    }
    
    // Show color filter panel for sets with parts
    colorFilterPanel.style.display = 'block';
    
    // Generate color filter buttons
    generateColorFilterButtons(inventory);
    
    // Create a map of original inventory for quick lookup and store globally
    originalInventoryMap = {};
    inventory.forEach(part => {
        // Include category information in the key to keep parts separate
        const key = `${part.part_number}_${part.color_id}_${part.is_spare ? 'spare' : 'regular'}_${part.is_minifig_part ? 'minifig' : 'normal'}`;
        originalInventoryMap[key] = part;
    });
    
    // Store all parts globally for filtering
    allInventoryParts = inventory;
    
    // Reset filter buttons
    resetModificationFilterButtons();
    resetCategoryFilterButtons();
    
    // Hide instance info if no instance is selected
    const instanceInfoCard = document.querySelector('#inventoryContainer .card:first-child');
    if (!currentlySelectedInstance) {
        if (instanceInfoCard) instanceInfoCard.style.display = 'none';
    } else {
        if (instanceInfoCard) instanceInfoCard.style.display = 'block';
    }
    
    // Update clear filters button visibility
    updateClearFiltersButtonVisibility();
    
    // Display filtered parts
    displayFilteredParts();
    
    document.getElementById('inventoryContainer').style.display = 'block';
}

function resetModificationFilterButtons() {
    // Update button appearance based on current filter state (don't change the filter itself)
    const buttons = document.querySelectorAll('.modification-filter-btn');
    buttons.forEach(button => {
        button.classList.remove('active');
        button.classList.add('btn-outline-primary', 'btn-outline-danger', 'btn-outline-success');
        button.classList.remove('btn-primary', 'btn-danger', 'btn-success');
        
        // Set the active button based on current filter state
        if (button.dataset.filter === currentModificationFilter) {
            button.classList.add('active');
            if (currentModificationFilter === 'all') {
                button.classList.remove('btn-outline-primary');
                button.classList.add('btn-primary');
            } else if (currentModificationFilter === 'missing') {
                button.classList.remove('btn-outline-danger');
                button.classList.add('btn-danger');
            } else if (currentModificationFilter === 'extra') {
                button.classList.remove('btn-outline-success');
                button.classList.add('btn-success');
            }
        }
    });
}

function setModificationFilter(filter) {
    // If clicking the currently active filter (and it's not 'all'), revert to 'all'
    if (currentModificationFilter === filter && filter !== 'all') {
        filter = 'all';
    }
    
    currentModificationFilter = filter;
    
    // Update button states
    const buttons = document.querySelectorAll('.modification-filter-btn');
    buttons.forEach(button => {
        button.classList.remove('active');
        const filterType = button.dataset.filter;
        
        // Reset all button styles
        button.classList.remove('btn-primary', 'btn-danger', 'btn-success');
        button.classList.add('btn-outline-primary', 'btn-outline-danger', 'btn-outline-success');
        
        // Set active button style
        if (button.dataset.filter === filter) {
            button.classList.add('active');
            if (filter === 'all') {
                button.classList.remove('btn-outline-primary');
                button.classList.add('btn-primary');
            } else if (filter === 'missing') {
                button.classList.remove('btn-outline-danger');
                button.classList.add('btn-danger');
            } else if (filter === 'extra') {
                button.classList.remove('btn-outline-success');
                button.classList.add('btn-success');
            }
        }
    });
    
    // Update clear filters button visibility
    updateClearFiltersButtonVisibility();
    
    // Apply filters
    displayFilteredParts();
}

function resetCategoryFilterButtons() {
    // Update button appearance based on current filter state (don't change the filter itself)
    const buttons = document.querySelectorAll('.category-filter-btn');
    buttons.forEach(button => {
        button.classList.remove('active');
        button.classList.add('btn-outline-primary', 'btn-outline-info', 'btn-outline-warning', 'btn-outline-secondary');
        button.classList.remove('btn-primary', 'btn-info', 'btn-warning', 'btn-secondary');
        
        // Set the active button based on current filter state
        if (button.dataset.filter === currentCategoryFilter) {
            button.classList.add('active');
            if (currentCategoryFilter === 'all') {
                button.classList.remove('btn-outline-primary');
                button.classList.add('btn-primary');
            } else if (currentCategoryFilter === 'regular') {
                button.classList.remove('btn-outline-info');
                button.classList.add('btn-info');
            } else if (currentCategoryFilter === 'minifig') {
                button.classList.remove('btn-outline-warning');
                button.classList.add('btn-warning');
            } else if (currentCategoryFilter === 'spare') {
                button.classList.remove('btn-outline-secondary');
                button.classList.add('btn-secondary');
            }
        }
    });
}

function setCategoryFilter(filter) {
    // If clicking the currently active filter (and it's not 'all'), revert to 'all'
    if (currentCategoryFilter === filter && filter !== 'all') {
        filter = 'all';
    }
    
    currentCategoryFilter = filter;
    
    // Update button states
    const buttons = document.querySelectorAll('.category-filter-btn');
    buttons.forEach(button => {
        button.classList.remove('active');
        
        // Reset all button styles
        button.classList.remove('btn-primary', 'btn-info', 'btn-warning', 'btn-secondary');
        button.classList.add('btn-outline-primary', 'btn-outline-info', 'btn-outline-warning', 'btn-outline-secondary');
        
        // Set active button style
        if (button.dataset.filter === filter) {
            button.classList.add('active');
            if (filter === 'all') {
                button.classList.remove('btn-outline-primary');
                button.classList.add('btn-primary');
            } else if (filter === 'regular') {
                button.classList.remove('btn-outline-info');
                button.classList.add('btn-info');
            } else if (filter === 'minifig') {
                button.classList.remove('btn-outline-warning');
                button.classList.add('btn-warning');
            } else if (filter === 'spare') {
                button.classList.remove('btn-outline-secondary');
                button.classList.add('btn-secondary');
            }
        }
    });
    
    // Update clear filters button visibility
    updateClearFiltersButtonVisibility();
    
    // Apply filters
    displayFilteredParts();
}

function displayFilteredParts() {
    const container = document.getElementById('inventoryList');
    container.innerHTML = '';
    
    if (!allInventoryParts || allInventoryParts.length === 0) {
        return;
    }
    
    // Filter parts based on modification status
    let filteredParts = allInventoryParts;
    
    if (currentModificationFilter !== 'all') {
        filteredParts = allInventoryParts.filter(part => {
            const partKey = `${part.part_number}_${part.color_id}_${part.is_spare ? 'spare' : 'regular'}_${part.is_minifig_part ? 'minifig' : 'normal'}`;
            const modifiedQty = modifiedInventory[partKey] || 0;
            const originalQty = originalInventoryMap[partKey] ? originalInventoryMap[partKey].quantity : part.quantity;
            const totalQty = originalQty + modifiedQty;
            const modificationFromOriginal = totalQty - originalQty;
            
            if (currentModificationFilter === 'missing') {
                return modificationFromOriginal < 0;
            } else if (currentModificationFilter === 'extra') {
                return modificationFromOriginal > 0;
            }
            return true;
        });
    }
    
    // Further filter by color if color filter is active
    if (selectedColors.size > 0) {
        filteredParts = filteredParts.filter(part => selectedColors.has(part.color_id));
    }
    
    // Further filter by category if category filter is active
    if (currentCategoryFilter !== 'all') {
        filteredParts = filteredParts.filter(part => {
            if (currentCategoryFilter === 'regular') {
                return !part.is_spare && !part.is_minifig_part;
            } else if (currentCategoryFilter === 'minifig') {
                return !part.is_spare && part.is_minifig_part;
            } else if (currentCategoryFilter === 'spare') {
                return part.is_spare;
            }
            return true;
        });
    }
    
    // Check if no parts match the current filters
    if (filteredParts.length === 0) {
        const noResultsMessage = createNoResultsMessage();
        container.appendChild(noResultsMessage);
        return;
    }
    
    // Separate parts by type and spare status
    const regularParts = filteredParts.filter(part => !part.is_spare && !part.is_minifig_part);
    const minifigParts = filteredParts.filter(part => !part.is_spare && part.is_minifig_part);
    const spareParts = filteredParts.filter(part => part.is_spare);
    
    // Sort regular parts to put "No Color/Any Color" (color ID 9999) at the top
    regularParts.sort((a, b) => {
        const aIsNoColor = a.color_id === 9999 || a.color_name === 'No Color' || a.color_name === 'Any Color';
        const bIsNoColor = b.color_id === 9999 || b.color_name === 'No Color' || b.color_name === 'Any Color';
        
        if (aIsNoColor && !bIsNoColor) return -1;
        if (!aIsNoColor && bIsNoColor) return 1;
        
        return 0;
    });
    
    // Determine if we should show section dividers (only when not filtering by specific category)
    const showDividers = currentCategoryFilter === 'all';
    
    // Display regular parts
    if (regularParts.length > 0) {
        const regularSection = document.createElement('div');
        regularSection.innerHTML = `
            <h6 class="mb-3"><i class="fas fa-cube"></i> Regular Parts (${regularParts.length})</h6>
        `;
        container.appendChild(regularSection);
        
        const regularGrid = document.createElement('div');
        regularGrid.className = `parts-grid cols-${currentColumnCount}`;
        container.appendChild(regularGrid);
        
        regularParts.forEach(part => {
            const partCard = createPartCard(part, originalInventoryMap);
            regularGrid.appendChild(partCard);
        });
    }
    
    // Display minifig parts
    if (minifigParts.length > 0) {
        const minifigSection = document.createElement('div');
        const dividerHtml = showDividers ? '<hr class="my-4">' : '';
        minifigSection.innerHTML = `
            ${dividerHtml}
            <h6 class="mb-3"><i class="fas fa-user"></i> Minifig Parts (${minifigParts.length})</h6>
        `;
        container.appendChild(minifigSection);
        
        const minifigGrid = document.createElement('div');
        minifigGrid.className = `parts-grid cols-${currentColumnCount}`;
        container.appendChild(minifigGrid);
        
        minifigParts.forEach(part => {
            const partCard = createPartCard(part, originalInventoryMap);
            minifigGrid.appendChild(partCard);
        });
    }
    
    // Display spare parts
    if (spareParts.length > 0) {
        const spareSection = document.createElement('div');
        const dividerHtml = showDividers ? '<hr class="my-4">' : '';
        spareSection.innerHTML = `
            ${dividerHtml}
            <h6 class="mb-3"><i class="fas fa-gift"></i> Spare Parts (${spareParts.length})</h6>
        `;
        container.appendChild(spareSection);
        
        const spareGrid = document.createElement('div');
        spareGrid.className = `parts-grid cols-${currentColumnCount}`;
        container.appendChild(spareGrid);
        
        spareParts.forEach(part => {
            const partCard = createPartCard(part, originalInventoryMap);
            spareGrid.appendChild(partCard);
        });
    }
    
    // Update instance status after displaying parts
    updateInstanceStatus();
}

function createNoResultsMessage() {
    const messageDiv = document.createElement('div');
    messageDiv.className = 'text-center py-5';
    
    // Determine the appropriate message based on active filters
    let iconClass = 'fas fa-filter';
    let title = 'No Parts Found';
    let message = 'No parts match your current filter criteria.';
    let suggestion = '';
    
    if (currentModificationFilter === 'missing') {
        iconClass = 'fas fa-minus-circle';
        title = 'No Missing Parts';
        message = 'You don\'t have any parts with reduced quantities.';
        suggestion = 'Try modifying some part quantities to see missing parts.';
    } else if (currentModificationFilter === 'extra') {
        iconClass = 'fas fa-plus-circle';
        title = 'No Extra Parts';
        message = 'You don\'t have any parts with increased quantities.';
        suggestion = 'Try adding extra parts to see them here.';
    } else if (selectedColors.size > 0) {
        iconClass = 'fas fa-palette';
        title = 'No Parts in Selected Colors';
        message = 'No parts match the selected color filters.';
        suggestion = 'Try selecting different colors or clear the color filter.';
    } else if (currentCategoryFilter === 'regular') {
        iconClass = 'fas fa-cube';
        title = 'No Regular Parts';
        message = 'This set contains no regular parts.';
        suggestion = 'Try selecting a different category or clear the category filter.';
    } else if (currentCategoryFilter === 'minifig') {
        iconClass = 'fas fa-user';
        title = 'No Minifigure Parts';
        message = 'This set contains no minifigure parts.';
        suggestion = 'Try selecting a different category or clear the category filter.';
    } else if (currentCategoryFilter === 'spare') {
        iconClass = 'fas fa-gift';
        title = 'No Spare Parts';
        message = 'This set contains no spare parts.';
        suggestion = 'Try selecting a different category or clear the category filter.';
    }
    
    messageDiv.innerHTML = `
        <i class="${iconClass} fa-3x text-muted mb-3"></i>
        <h5 class="text-muted">${title}</h5>
        <p class="text-muted">${message}</p>
        ${suggestion ? `<p class="text-muted small">${suggestion}</p>` : ''}
        <button class="btn btn-outline-secondary btn-sm mt-2" onclick="clearAllFilters()">
            <i class="fas fa-times"></i> Clear All Filters
        </button>
    `;
    
    return messageDiv;
}

// Description editing functions
function editDescription() {
    const descriptionDiv = document.getElementById('instanceDescription');
    const descriptionInput = document.getElementById('descriptionInput');
    const descriptionText = document.getElementById('descriptionText');
    
    // Hide the display div and show the input
    descriptionDiv.style.display = 'none';
    descriptionInput.style.display = 'block';
    
    // Set the current text as the input value
    const currentText = descriptionText.textContent;
    if (currentText === 'Click to add a description for this set instance...') {
        descriptionInput.value = '';
    } else {
        descriptionInput.value = currentText;
    }
    
    // Focus and select the input
    descriptionInput.focus();
    descriptionInput.select();
}

function saveDescription() {
    const descriptionDiv = document.getElementById('instanceDescription');
    const descriptionInput = document.getElementById('descriptionInput');
    const descriptionText = document.getElementById('descriptionText');
    
    const newDescription = descriptionInput.value.trim();
    
    // Hide the input and show the display div
    descriptionInput.style.display = 'none';
    descriptionDiv.style.display = 'flex';
    
    // Update the display text
    if (newDescription === '') {
        descriptionText.textContent = 'Click to add a description for this set instance...';
        descriptionDiv.classList.remove('has-content');
    } else {
        descriptionText.textContent = newDescription;
        descriptionDiv.classList.add('has-content');
    }
    
    // Save to database if we have a current instance
    if (currentSetNumber && currentlySelectedInstance) {
        updateInstanceDescription(newDescription);
    }
}

function handleDescriptionKeyPress(event) {
    if (event.key === 'Enter') {
        event.preventDefault();
        saveDescription();
    } else if (event.key === 'Escape') {
        event.preventDefault();
        // Cancel editing without saving
        const descriptionDiv = document.getElementById('instanceDescription');
        const descriptionInput = document.getElementById('descriptionInput');
        
        descriptionInput.style.display = 'none';
        descriptionDiv.style.display = 'flex';
    }
}

async function updateInstanceDescription(description) {
    if (!currentSetNumber || !currentlySelectedInstance) {
        return;
    }
    
    const inventoryId = getCurrentUserInventoryId();
    if (!inventoryId) {
        console.error('No user inventory ID available');
        return;
    }
    
    try {
        const response = await fetch('/update_inventory_name', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                user_inventory_id: inventoryId,
                new_description: description
            })
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            console.error('Failed to update description:', errorData.error);
            showAlert('Failed to save description: ' + errorData.error, 'danger');
        }
    } catch (error) {
        console.error('Error updating description:', error);
        showAlert('Network error while saving description', 'danger');
    }
}

function getCurrentUserInventoryId() {
    // This function should return the current user inventory ID
    // We'll need to track this when an instance is selected
    return currentUserInventoryId || null;
}

function setCurrentUserInventoryId(inventoryId) {
    currentUserInventoryId = inventoryId;
}

async function loadInstanceDescription(setNumber, instanceName) {
    try {
        const response = await fetch(`/get_user_inventories/${setNumber}`);
        if (response.ok) {
            const inventories = await response.json();
            const currentInventory = inventories.find(inv => inv.inventory_name === instanceName);
            
            if (currentInventory) {
                setCurrentUserInventoryId(currentInventory.user_inventory_id);
                updateDescriptionDisplay(currentInventory.description || '');
            } else {
                setCurrentUserInventoryId(null);
                updateDescriptionDisplay('');
            }
        } else {
            setCurrentUserInventoryId(null);
            updateDescriptionDisplay('');
        }
    } catch (error) {
        console.error('Error loading instance description:', error);
        setCurrentUserInventoryId(null);
        updateDescriptionDisplay('');
    }
}

function updateDescriptionDisplay(description) {
    const descriptionDiv = document.getElementById('instanceDescription');
    const descriptionText = document.getElementById('descriptionText');
    
    if (description && description.trim() !== '') {
        descriptionText.textContent = description;
        descriptionDiv.classList.add('has-content');
    } else {
        descriptionText.textContent = 'Click to add a description for this set instance...';
        descriptionDiv.classList.remove('has-content');
    }
}

function getContrastColor(hexColor) {
    // Remove # if present
    hexColor = hexColor.replace('#', '');
    
    // Convert to RGB
    const r = parseInt(hexColor.substr(0, 2), 16);
    const g = parseInt(hexColor.substr(2, 2), 16);
    const b = parseInt(hexColor.substr(4, 2), 16);
    
    // Calculate brightness using luminance formula
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    
    // Return black for light colors, white for dark colors
    return brightness > 128 ? '#000000' : '#ffffff';
}

// Global variables for color filtering
let selectedColors = new Set();
let allInventoryParts = [];
let currentSetNumber = null;

// Global variables for modification filtering
let currentModificationFilter = 'all'; // 'all', 'missing', 'extra'

// Global variables for category filtering
let currentCategoryFilter = 'all'; // 'all', 'regular', 'minifig', 'spare'

// Global variable for grid column count
let currentColumnCount = 8; // Default to 8 columns

// Global variable for tracking current user inventory ID
let currentUserInventoryId = null;

async function checkBuildingInstructionsAvailability(setNumber) {
    // Remove the -digit suffix from the set number
    const cleanSetNumber = setNumber.replace(/-\d+$/, '');
    
    const legoBtn = document.getElementById('legoInstructionsBtn');
    const brickBtn = document.getElementById('buildingInstructionsBtn');
    
    // Set initial state - buttons are hidden but ready to show
    legoBtn.style.display = 'none';
    legoBtn.classList.remove('show');
    brickBtn.style.display = 'none';
    brickBtn.classList.remove('show');
    
    // Check cache first
    const cachedData = getCachedInstructionAvailability(cleanSetNumber);
    if (cachedData) {
        console.log('Using cached instruction availability for', cleanSetNumber);
        
        // Show buttons based on cached data
        if (cachedData.lego) {
            legoBtn.style.display = 'inline-block';
            setTimeout(() => {
                legoBtn.classList.add('show');
            }, 10);
        }
        
        if (cachedData.brick) {
            brickBtn.style.display = 'inline-block';
            setTimeout(() => {
                brickBtn.classList.add('show');
            }, 10);
        }
        
        return; // Exit early if we have cached data
    }
    
    console.log('No cache found, checking external sources for', cleanSetNumber);
    
    // Check LEGO instructions availability
    let legoAvailable = false;
    try {
        const legoResponse = await fetch('/check_instructions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ set_number: cleanSetNumber })
        });
        const legoResult = await legoResponse.json();
        legoAvailable = legoResult.has_instructions;
        
        if (legoAvailable) {
            legoBtn.style.display = 'inline-block';
            // Smooth fade in using CSS class
            setTimeout(() => {
                legoBtn.classList.add('show');
            }, 10);
        }
    } catch (error) {
        console.log('Could not verify LEGO instructions availability:', error);
    }
    
    // Check BrickInstructions availability
    let brickAvailable = false;
    try {
        // Check if instruction images are available from brickinstructions.com
        const response = await fetch('/get_instruction_images', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ set_number: cleanSetNumber })
        });
        
        const result = await response.json();
        brickAvailable = result.success && result.count > 1;
        
        if (brickAvailable) {
            brickBtn.style.display = 'inline-block';
            // Smooth fade in using CSS class
            setTimeout(() => {
                brickBtn.classList.add('show');
            }, 10);
        }
        
    } catch (error) {
        console.log('Could not verify building instructions availability:', error);
    }
    
    // Cache the results
    setCachedInstructionAvailability(cleanSetNumber, legoAvailable, brickAvailable);
}

async function openBuildingInstructions() {
    if (!currentSetNumber) {
        alert('No set selected');
        return;
    }
    
    // Remove the -digit suffix from the set number
    const cleanSetNumber = currentSetNumber.replace(/-\d+$/, '');
    
    try {
        // Show loading state
        const button = document.getElementById('buildingInstructionsBtn');
        const originalText = button.innerHTML;
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
        button.disabled = true;
        
        // Fetch instruction images
        const response = await fetch('/get_instruction_images', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ set_number: cleanSetNumber })
        });
        
        const result = await response.json();
        
        // Reset button state
        button.innerHTML = originalText;
        button.disabled = false;
        
        if (result.success) {
            // Show instruction images in a modal
            showInstructionModal(result.images, cleanSetNumber);
        } else {
            alert(`Could not load instructions: ${result.error}`);
        }
        
    } catch (error) {
        // Reset button state
        const button = document.getElementById('buildingInstructionsBtn');
        button.innerHTML = '<i class="fas fa-book"></i> BrickInstructions';
        button.disabled = false;
        
        alert('Error loading instructions: ' + error.message);
    }
}

function openLegoInstructions() {
    if (!currentSetNumber) {
        alert('No set selected');
        return;
    }
    
    const cleanSetNumber = currentSetNumber.replace(/-\d+$/, '');
    const legoUrl = `https://www.lego.com/en-us/service/building-instructions/${cleanSetNumber}`;
    
    // Open in a new tab
    window.open(legoUrl, '_blank');
}

function showInstructionModal(images, setNumber) {
    const modal = new bootstrap.Modal(document.getElementById('instructionModal'));
    const modalTitle = document.getElementById('instructionModalLabel');
    const imagesContainer = document.getElementById('instructionImages');
    
    // Update modal title with clickable link
    modalTitle.innerHTML = `<i class="fas fa-book"></i> <a href="https://lego.brickinstructions.com/lego_instructions/set/${setNumber}" target="_blank" class="text-decoration-none">BrickInstructions - Set ${setNumber}</a>`;
    
    // Clear previous images
    imagesContainer.innerHTML = '';
    
    if (images.length === 0) {
        imagesContainer.innerHTML = '<p class="text-muted">No instruction images found.</p>';
    } else {
        // Create image elements
        images.forEach((imageUrl, index) => {
            const img = document.createElement('img');
            img.src = imageUrl;
            img.className = 'img-fluid border rounded shadow-sm';
            img.style.maxWidth = '100%';
            img.style.height = 'auto';
            img.alt = `Instruction page ${index + 1}`;
            img.loading = 'lazy';
            
            imagesContainer.appendChild(img);
        });
    }
    
    // Show the modal
    modal.show();
}

function generateColorFilterButtons(inventory) {
    const colorButtonsContainer = document.getElementById('colorFilterButtons');
    colorButtonsContainer.innerHTML = '';
    
    // Get unique colors from inventory
    const uniqueColors = new Map();
    inventory.forEach(part => {
        const colorKey = `${part.color_id}_${part.color_name}`;
        if (!uniqueColors.has(colorKey)) {
            uniqueColors.set(colorKey, {
                color_id: part.color_id,
                color_name: part.color_name,
                color_rgb: part.color_rgb
            });
        }
    });
    
    // Sort colors by name
    const sortedColors = Array.from(uniqueColors.values()).sort((a, b) => a.color_name.localeCompare(b.color_name));
    
    // Create color filter buttons
    sortedColors.forEach(color => {
        const button = document.createElement('button');
        button.className = 'btn btn-sm color-filter-btn';
        button.style.cssText = `
            background-color: #${color.color_rgb};
            color: ${getContrastColor(color.color_rgb)};
            border: 1px solid #ccc;
            margin: 2px;
        `;
        button.textContent = color.color_name;
        button.onclick = () => toggleColorFilter(color.color_id);
        button.dataset.colorId = color.color_id;
        
        // Preserve selected state if this color was previously selected
        if (selectedColors.has(color.color_id)) {
            button.style.border = '2px solid #007bff';
            button.style.boxShadow = '0 0 5px rgba(0, 123, 255, 0.5)';
        }
        
        colorButtonsContainer.appendChild(button);
    });
}

function toggleColorFilter(colorId) {
    if (selectedColors.has(colorId)) {
        selectedColors.delete(colorId);
    } else {
        selectedColors.add(colorId);
    }
    
    // Update button appearance
    const buttons = document.querySelectorAll('.color-filter-btn');
    buttons.forEach(button => {
        const buttonColorId = parseInt(button.dataset.colorId);
        if (selectedColors.has(buttonColorId)) {
            button.style.border = '2px solid #007bff';
            button.style.boxShadow = '0 0 5px rgba(0, 123, 255, 0.5)';
        } else {
            button.style.border = '1px solid #ccc';
            button.style.boxShadow = 'none';
        }
    });
    
    // Update clear filters button visibility
    updateClearFiltersButtonVisibility();
    
    // Apply filter
    applyColorFilter();
}

function clearColorFilter() {
    selectedColors.clear();
    
    // Reset button appearances
    const buttons = document.querySelectorAll('.color-filter-btn');
    buttons.forEach(button => {
        button.style.border = '1px solid #ccc';
        button.style.boxShadow = 'none';
    });
    
    // Update clear filters button visibility
    updateClearFiltersButtonVisibility();
    
    // Show all parts
    applyColorFilter();
}

function updateClearFiltersButtonVisibility() {
    const clearBtn = document.getElementById('clearAllFiltersBtn');
    if (!clearBtn) return;
    
    // Check if any filters are active
    const hasColorFilters = selectedColors.size > 0;
    const hasModificationFilter = currentModificationFilter !== 'all';
    const hasCategoryFilter = currentCategoryFilter !== 'all';
    
    const hasActiveFilters = hasColorFilters || hasModificationFilter || hasCategoryFilter;
    
    // Show/hide the button
    clearBtn.style.display = hasActiveFilters ? 'block' : 'none';
}

function clearAllFilters() {
    // Clear color filters
    selectedColors.clear();
    
    // Reset color filter button appearances
    const colorButtons = document.querySelectorAll('.color-filter-btn');
    colorButtons.forEach(button => {
        button.style.border = '1px solid #ccc';
        button.style.boxShadow = 'none';
    });
    
    // Reset modification filter
    currentModificationFilter = 'all';
    resetModificationFilterButtons();
    
    // Reset category filter
    currentCategoryFilter = 'all';
    resetCategoryFilterButtons();
    
    // Update button visibility
    updateClearFiltersButtonVisibility();
    
    // Apply filters
    displayFilteredParts();
}

function resetAllFiltersForNewSearch() {
    // This function should be called when starting a new search to reset all filters
    selectedColors.clear();
    currentModificationFilter = 'all';
    currentCategoryFilter = 'all';
    currentColumnCount = 8; // Reset to default 8 columns
}

function refreshColorFilterButtons() {
    // Update the appearance of color filter buttons based on current selection state
    const colorButtons = document.querySelectorAll('.color-filter-btn');
    colorButtons.forEach(button => {
        const colorId = parseInt(button.dataset.colorId);
        if (selectedColors.has(colorId)) {
            button.style.border = '2px solid #007bff';
            button.style.boxShadow = '0 0 5px rgba(0, 123, 255, 0.5)';
            } else {
            button.style.border = '1px solid #ccc';
            button.style.boxShadow = 'none';
            }
        });
    }

function applyColorFilter() {
    // Use the new unified filtering system
    displayFilteredParts();
}


function createPartCard(part, originalMap = {}) {
    // Generate part key that includes category information
    const partKey = `${part.part_number}_${part.color_id}_${part.is_spare ? 'spare' : 'regular'}_${part.is_minifig_part ? 'minifig' : 'normal'}`;
    const modifiedQty = modifiedInventory[partKey] || 0;
    
    // Get original quantity from the original inventory map
    const originalPart = originalMap[partKey];
    const originalQty = originalPart ? originalPart.quantity : part.quantity;
    const totalQty = originalQty + modifiedQty;
    
    // Calculate modification from original
    const modificationFromOriginal = totalQty - originalQty;
    
    const partCard = document.createElement('div');
    partCard.className = 'card part-card mb-3';
    partCard.dataset.partKey = partKey;
    partCard.innerHTML = `
        <div class="card-body">
            <div class="row align-items-center">
                <div class="text-center mb-2">
                    <img src="${part.part_image_url || 'https://via.placeholder.com/80x80?text=No+Image'}" 
                             alt="${part.part_name}" 
                             class="part-image"
                         onerror="this.src='https://via.placeholder.com/80x80?text=No+Image'">
                    </div>
                <div class="col-12 text-center">
                    <!-- Part info row -->
                    <div class="mb-2">
                    <strong>${part.part_number}</strong><br>
                    <small class="text-muted">${part.part_name}</small>
                </div>
                    <!-- Quantity controls row -->
                    <div class="mb-2 quantity-label-container">
                        ${modificationFromOriginal !== 0 ? `<small class="text-primary">Original: ${originalQty}</small><small class="${modificationFromOriginal > 0 ? 'text-success' : 'text-danger'}"> (${modificationFromOriginal > 0 ? '+' : ''}${modificationFromOriginal})</small>` : ''}
                </div>
                    <div class="quantity-controls">
                        <button class="btn btn-outline-danger btn-sm" onclick="modifyQuantity('${partKey}', -1)" 
                                ${totalQty <= 0 ? 'disabled title="Cannot reduce below zero"' : ''}>
                            <i class="fas fa-minus"></i>
                        </button>
                        <span class="quantity-display" id="qty_${partKey}">${totalQty}</span>
                        <button class="btn btn-outline-success btn-sm" onclick="modifyQuantity('${partKey}', 1)">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;
    return partCard;
}

function modifyQuantity(partKey, change) {
    if (!currentSetNumber) return;
    
    // Get the original quantity from the original inventory map
    const originalPart = originalInventoryMap[partKey];
    const originalQty = originalPart ? originalPart.quantity : 0;

    // Update local state
    const previousModifiedQty = modifiedInventory[partKey] || 0;
    modifiedInventory[partKey] = previousModifiedQty + change;
    
    // Update the display without refreshing the entire inventory
    updateQuantityDisplay(partKey, originalQty, modifiedInventory[partKey]);
    
    // Update instance status
    updateInstanceStatus();
    
    // Refresh the filtered display to update modification filter results
    if (currentModificationFilter !== 'all') {
        displayFilteredParts();
    }
    
    // Automatically save the changes
    autoSaveInventory();
}

async function autoSaveInventory() {
    if (!currentSetNumber || !currentlySelectedInstance) {
        return;
    }
    
    // Show brief auto-save indicator
    showAutoSaveIndicator();
    
    try {
        const response = await fetch('/update_inventory', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                set_number: currentSetNumber,
                instance_name: currentlySelectedInstance,
                modifications: modifiedInventory
            })
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            console.error('Auto-save failed:', errorData.error);
            // Don't show alert for auto-save failures to avoid interrupting user experience
            // The user can still manually save if needed
        }
    } catch (error) {
        console.error('Auto-save error:', error);
        // Silently handle auto-save errors to avoid interrupting user experience
    }
}

function showAutoSaveIndicator() {
    // Create or update auto-save indicator
    let indicator = document.getElementById('autoSaveIndicator');
    if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'autoSaveIndicator';
        indicator.className = 'auto-save-indicator';
        indicator.innerHTML = '<i class="fas fa-save"></i> Auto-saved';
        document.body.appendChild(indicator);
    }
    
    // Show the indicator
    indicator.style.display = 'block';
    indicator.style.opacity = '1';
    
    // Hide after 2 seconds
    setTimeout(() => {
        indicator.style.opacity = '0';
        setTimeout(() => {
            indicator.style.display = 'none';
        }, 300);
    }, 2000);
}

async function loadModifiedInventory(setNumber, instanceName = 'Default') {
    try {
        const response = await fetch(`/get_modified_inventory/${setNumber}?instance_name=${encodeURIComponent(instanceName)}`);
        if (response.ok) {
            modifiedInventory = await response.json();
        }
    } catch (error) {
        console.error('Failed to load modified inventory:', error);
    }
}

function showLoading(show) {
    const loadingElement = document.getElementById('loadingSpinner');
    if (show) {
        loadingElement.style.display = 'block';
        // Update loading message based on current action
        const loadingText = loadingElement.querySelector('p');
        if (loadingText) {
            loadingText.textContent = 'Loading set information...';
        }
    } else {
        loadingElement.style.display = 'none';
    }
}

function updateInstanceStatus() {
    const detailedStatusElement = document.getElementById('instanceStatusDetailed');
    
    if (!detailedStatusElement) {
        return; // Element doesn't exist yet
    }
    
    if (!allInventoryParts || allInventoryParts.length === 0) {
        detailedStatusElement.innerHTML = '';
        return;
    }
    
    let totalMissing = 0;
    let totalExtra = 0;
    let totalOriginalQty = 0;
    let totalCurrentQty = 0;
    
    // Calculate total modifications and quantities (excluding spares)
    allInventoryParts.forEach(part => {
        // Skip spare parts for completion percentage calculation
        if (part.is_spare) {
            return;
        }
        
        const partKey = `${part.part_number}_${part.color_id}_${part.is_spare ? 'spare' : 'regular'}_${part.is_minifig_part ? 'minifig' : 'normal'}`;
        const originalPart = originalInventoryMap[partKey];
        const originalQty = originalPart ? originalPart.quantity : part.quantity;
        const modifiedQty = modifiedInventory[partKey] || 0;
        const totalQty = originalQty + modifiedQty;
        const modification = totalQty - originalQty;
        
        // Count all parts for total quantities (excluding spares)
        totalOriginalQty += originalQty;
        totalCurrentQty += totalQty;
        
        if (modification < 0) {
            totalMissing += Math.abs(modification);
        } else if (modification > 0) {
            totalExtra += modification;
        }
    });
    
    
    // Calculate completion percentage (excluding spares and extra parts)
    const completionPercentage = totalOriginalQty > 0 ? Math.round((totalCurrentQty / totalOriginalQty) * 100) : 100;
    
    // Create detailed status display
    const isComplete = totalMissing === 0 && totalExtra === 0;
    const completionStatus = isComplete ? 'Complete' : 'Incomplete';
    const completionClass = isComplete ? 'text-success' : 'text-warning';
    
    const detailedStatusHtml = `
        <div class="status-item">
            <span class="status-label">Completion:</span>
            <span class="status-value ${completionClass}">${completionStatus} (${completionPercentage}%)</span>
        </div>
        <div class="status-item">
            <span class="status-label">Missing:</span>
            <span class="status-value ${totalMissing > 0 ? 'text-danger' : 'text-muted'}">${totalMissing}</span>
        </div>
        <div class="status-item">
            <span class="status-label">Extra:</span>
            <span class="status-value ${totalExtra > 0 ? 'text-success' : 'text-muted'}">${totalExtra}</span>
        </div>
    `;
    
    detailedStatusElement.innerHTML = detailedStatusHtml;
}

function updateQuantityDisplay(partKey, originalQty, modifiedQty) {
    // Update the quantity display
    const qtyElement = document.getElementById(`qty_${partKey}`);
    if (qtyElement) {
        qtyElement.textContent = originalQty + modifiedQty;
    }
    
    // Update the combined original/modification label
    const partCard = qtyElement ? qtyElement.closest('.card') : null;
    if (partCard) {
        // Find the container with the original quantity label using specific class
        const originalLabelContainer = partCard.querySelector('.quantity-label-container');
        if (originalLabelContainer) {
            const totalQty = originalQty + modifiedQty;
            const modificationFromOriginal = totalQty - originalQty;
            
            // Update the combined label - only show original if there's a modification
            if (modificationFromOriginal !== 0) {
                originalLabelContainer.innerHTML = `
                    <small class="text-primary">Original: ${originalQty}</small>
                    <small class="${modificationFromOriginal > 0 ? 'text-success' : 'text-danger'}"> (${modificationFromOriginal > 0 ? '+' : ''}${modificationFromOriginal})</small>
                `;
            } else {
                originalLabelContainer.innerHTML = ''; // Hide when no modification
            }
        }
        
        // Update button states
        const minusButton = partCard.querySelector('.btn-outline-danger');
        if (minusButton) {
            const totalQty = originalQty + modifiedQty;
            if (totalQty <= 0) {
                minusButton.disabled = true;
                minusButton.title = "Cannot reduce below zero";
                minusButton.classList.add('disabled');
            } else {
                minusButton.disabled = false;
                minusButton.title = "";
                minusButton.classList.remove('disabled');
            }
        }
    }
}


// Collection management functions
async function getInstances(setNumber) {
    try {
        const response = await fetch(`/get_user_sets/${setNumber}`);
        
        if (!response.ok) {
            console.error(`Failed to load instances: ${response.status} ${response.statusText}`);
            return [];
        }
        
        const instances = await response.json();
        return instances;
    } catch (error) {
        console.error('Error loading existing instances:', error);
        return [];
    }
}

function displayInstances(instances, setNumber) {
    const instanceSelectionList = document.getElementById('instanceSelectionList');
    const instanceSelectionText = document.getElementById('instanceSelectionText');
    instanceSelectionList.innerHTML = '';
    
    // Update the descriptive text based on whether instances exist
    if (instances.length === 0) {
        instanceSelectionText.textContent = 'You don\'t have any instances of this set yet. Add your first instance below:';
    } else {
        instanceSelectionText.textContent = 'You have existing instances of this set. Choose which one to view or add a new instance:';
    }
    
    instances.forEach(instance => {
        const instanceDiv = document.createElement('div');
        
        // Check if this is the currently selected instance
        const isSelected = currentlySelectedInstance === instance.instance_name;
        
        // Apply different styling for selected vs unselected instances
        if (isSelected) {
            instanceDiv.className = 'alert alert-success d-flex justify-content-between align-items-center mb-2 border border-success border-2';
            instanceDiv.style.cursor = 'pointer';
            instanceDiv.innerHTML = `
                <div onclick="instanceClicked('${setNumber}', '${instance.instance_name}')" style="flex: 1;">
                    <strong>
                        <span class="editable-instance-name" 
                              data-inventory-id="${instance.id}" 
                              data-current-name="${instance.instance_name}"
                              style="cursor: pointer; border-bottom: 1px dashed #28a745;"
                              title="Click to edit name"
                              onclick="event.stopPropagation(); startEditingInstanceName(this)">
                            ${instance.instance_name}
                        </span>
                        <span class="badge bg-success ms-2"><i class="fas fa-check"></i> Selected</span>
                    </strong>
                    <small class="text-muted d-block">Added: ${new Date(instance.added_at).toLocaleDateString()}</small>
                </div>
                <div class="btn-group" role="group">
                    <button class="btn btn-outline-danger btn-sm" onclick="event.stopPropagation(); deleteSetInstance(${instance.id}, '${instance.instance_name}')">
                        <i class="fas fa-trash"></i> Delete
                    </button>
                </div>
            `;
        } else {
            instanceDiv.className = 'alert alert-primary d-flex justify-content-between align-items-center mb-2';
            instanceDiv.style.cursor = 'pointer';
            instanceDiv.innerHTML = `
                <div onclick="instanceClicked('${setNumber}', '${instance.instance_name}')" style="flex: 1;">
                    <strong>
                        <span class="editable-instance-name" 
                              data-inventory-id="${instance.id}" 
                              data-current-name="${instance.instance_name}"
                              style="cursor: pointer; border-bottom: 1px dashed #007bff;"
                              title="Click to edit name"
                              onclick="event.stopPropagation(); startEditingInstanceName(this)">
                            ${instance.instance_name}
                        </span>
                    </strong>
                    <small class="text-muted d-block">Added: ${new Date(instance.added_at).toLocaleDateString()}</small>
                </div>
                <div class="btn-group" role="group">
                    <button class="btn btn-danger btn-sm" onclick="event.stopPropagation(); deleteSetInstance(${instance.id}, '${instance.instance_name}')">
                        <i class="fas fa-trash"></i> Delete
                    </button>
                </div>
            `;
        }
        
        instanceSelectionList.appendChild(instanceDiv);
    });
    
    // Update instance items for keyboard navigation
    // updateInstanceItems();
}

function updateInstanceSelectionDisplay(setNumber, selectedInstanceName) {
    const instanceSelectionList = document.getElementById('instanceSelectionList');
    const instanceDivs = instanceSelectionList.querySelectorAll('div[onclick*="instanceClicked"]');
    
    instanceDivs.forEach(instanceDiv => {
        const parentDiv = instanceDiv.closest('.alert');
        const instanceName = instanceDiv.onclick.toString().match(/'([^']+)'\)/)[1];
        
        if (instanceName === selectedInstanceName) {
            // Update to selected styling
            parentDiv.className = 'alert alert-success d-flex justify-content-between align-items-center mb-2 border border-success border-2';
            const strongElement = instanceDiv.querySelector('strong');
            if (strongElement && !strongElement.innerHTML.includes('Selected')) {
                // Preserve the editable span structure
                const editableSpan = strongElement.querySelector('.editable-instance-name');
                if (editableSpan) {
                    strongElement.innerHTML = `
                        <span class="editable-instance-name" 
                              data-inventory-id="${editableSpan.dataset.inventoryId}" 
                              data-current-name="${editableSpan.dataset.currentName}"
                              style="cursor: pointer; border-bottom: 1px dashed #28a745;"
                              title="Click to edit name"
                              onclick="event.stopPropagation(); startEditingInstanceName(this)">
                            ${editableSpan.dataset.currentName}
                        </span>
                        <span class="badge bg-success ms-2"><i class="fas fa-check"></i> Selected</span>
                    `;
                } else {
                    strongElement.innerHTML = `${instanceName} <span class="badge bg-success ms-2"><i class="fas fa-check"></i> Selected</span>`;
                }
            }
        } else {
            // Update to unselected styling
            parentDiv.className = 'alert alert-primary d-flex justify-content-between align-items-center mb-2';
            const strongElement = instanceDiv.querySelector('strong');
            if (strongElement && strongElement.innerHTML.includes('Selected')) {
                // Preserve the editable span structure
                const editableSpan = strongElement.querySelector('.editable-instance-name');
                if (editableSpan) {
                    strongElement.innerHTML = `
                        <span class="editable-instance-name" 
                              data-inventory-id="${editableSpan.dataset.inventoryId}" 
                              data-current-name="${editableSpan.dataset.currentName}"
                              style="cursor: pointer; border-bottom: 1px dashed #007bff;"
                              title="Click to edit name"
                              onclick="event.stopPropagation(); startEditingInstanceName(this)">
                            ${editableSpan.dataset.currentName}
                        </span>
                    `;
                } else {
                    strongElement.innerHTML = instanceName;
                }
            }
        }
    });
}

function removeInstanceFromDisplay(instanceName) {
    const instanceSelectionList = document.getElementById('instanceSelectionList');
    const instanceSelectionText = document.getElementById('instanceSelectionText');
    const instanceDivs = instanceSelectionList.querySelectorAll('div[onclick*="instanceClicked"]');
    
    let deletedInstanceIndex = -1;
    let deletedInstanceDiv = null;
    
    // Find the instance to delete and its index
    instanceDivs.forEach((instanceDiv, index) => {
        const currentInstanceName = instanceDiv.onclick.toString().match(/'([^']+)'\)/)[1];
        
        if (currentInstanceName === instanceName) {
            deletedInstanceIndex = index;
            deletedInstanceDiv = instanceDiv;
        }
    });
    instanceItems.splice(deletedInstanceIndex, 1);
    
    // Check if the deleted instance is currently selected
    const wasCurrentlySelected = currentlySelectedInstance === instanceName;
    
    // Remove the instance from the DOM
    if (deletedInstanceDiv) {
        const parentDiv = deletedInstanceDiv.closest('.alert');
        parentDiv.remove();
    }
    
    // If the deleted instance was currently selected, select another instance
    if (wasCurrentlySelected) {
        const remainingInstanceDivs = instanceSelectionList.querySelectorAll('div[onclick*="instanceClicked"]');
        
        if (remainingInstanceDivs.length > 0) {
            // Try to select the instance at the same index (below), or the one above if none below
            let targetIndex = deletedInstanceIndex;
            if (targetIndex >= remainingInstanceDivs.length) {
                targetIndex = remainingInstanceDivs.length - 1; // Select the last one (above)
            }
            
            const targetInstanceDiv = remainingInstanceDivs[targetIndex];
            const targetInstanceName = targetInstanceDiv.onclick.toString().match(/'([^']+)'\)/)[1];
            
            // Automatically select the target instance
            selectInstance(currentSetNumber, targetInstanceName);
        } else {
            // No instances left, clear the current selection
            currentlySelectedInstance = null;
            document.getElementById('inventoryContainer').style.display = 'none';
        }
    }
    
    // Check if there are any instances left and update text accordingly
    const remainingInstances = instanceSelectionList.querySelectorAll('.alert');
    if (remainingInstances.length === 0) {
        instanceSelectionText.textContent = 'You don\'t have any instances of this set yet. Add your first instance below:';
        // Reset instance navigation when no instances remain
        resetInstanceNavigation();
    }
}

function addInstanceToDisplay(instance, setNumber) {
    const instanceSelectionList = document.getElementById('instanceSelectionList');
    const instanceSelectionText = document.getElementById('instanceSelectionText');
    
    // Create the new instance div
    const instanceDiv = document.createElement('div');
    instanceDiv.className = 'alert alert-primary d-flex justify-content-between align-items-center mb-2';
    instanceDiv.style.cursor = 'pointer';
    instanceDiv.innerHTML = `
        <div onclick="instanceClicked('${setNumber}', '${instance.instance_name}')" style="flex: 1;">
            <strong>
                <span class="editable-instance-name" 
                      data-inventory-id="${instance.id}" 
                      data-current-name="${instance.instance_name}"
                      style="cursor: pointer; border-bottom: 1px dashed #007bff;"
                      title="Click to edit name"
                      onclick="event.stopPropagation(); startEditingInstanceName(this)">
                    ${instance.instance_name}
                </span>
            </strong>
            <small class="text-muted d-block">Added: ${new Date(instance.added_at).toLocaleDateString()}</small>
        </div>
        <div class="btn-group" role="group">
            <button class="btn btn-danger btn-sm" onclick="event.stopPropagation(); deleteSetInstance(${instance.id}, '${instance.instance_name}')">
                <i class="fas fa-trash"></i> Delete
            </button>
        </div>
    `;
    
    // Add the new instance to the list
    instanceSelectionList.appendChild(instanceDiv);
    
    // Update the descriptive text since we now have instances
    instanceSelectionText.textContent = 'You have existing instances of this set. Choose which one to view or add a new instance:';
    
    // Update instance items for keyboard navigation
    instanceItems.push(instance);
}

function instanceClicked(setNumber, instanceName) {
    navigationInstance = true;
    selectInstance(setNumber, instanceName);
}

function startEditingInstanceName(element) {
    const currentName = element.dataset.currentName;
    const inventoryId = element.dataset.inventoryId;
    
    // Store original content
    const originalContent = element.innerHTML;
    
    // Create input field
    const input = document.createElement('input');
    input.type = 'text';
    input.value = currentName;
    input.className = 'form-control form-control-sm';
    input.style.display = 'inline-block';
    input.style.width = '150px';
    input.style.fontSize = '0.875rem';
    input.style.fontWeight = 'bold';
    
    // Create save button
    const saveBtn = document.createElement('button');
    saveBtn.className = 'btn btn-success btn-sm ms-1';
    saveBtn.innerHTML = '<i class="fas fa-check"></i>';
    saveBtn.style.fontSize = '0.75rem';
    saveBtn.style.padding = '0.25rem 0.5rem';
    
    // Create cancel button
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn btn-secondary btn-sm ms-1';
    cancelBtn.innerHTML = '<i class="fas fa-times"></i>';
    cancelBtn.style.fontSize = '0.75rem';
    cancelBtn.style.padding = '0.25rem 0.5rem';
    
    // Replace content with input and buttons
    element.innerHTML = '';
    element.appendChild(input);
    element.appendChild(saveBtn);
    element.appendChild(cancelBtn);
    
    // Focus the input
    input.focus();
    input.select();
    
    // Save function
    const save = async () => {
        const newName = input.value.trim();
        
        if (newName === currentName) {
            // No change, just cancel
            cancel();
            return;
        }
        
        if (newName.length === 0) {
            showAlert('Name cannot be empty', 'warning');
            input.focus();
            return;
        }
        
        // Check if name is already taken by another instance
        const existingNames = Array.from(document.querySelectorAll('.editable-instance-name'))
            .map(el => el.dataset.currentName)
            .filter(name => name !== currentName);
        
        if (existingNames.includes(newName)) {
            showAlert('An instance with this name already exists', 'warning');
            input.focus();
            return;
        }
        
        try {
            const response = await fetch('/update_inventory_name', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    user_inventory_id: inventoryId,
                    new_name: newName
                })
            });
            
            const data = await response.json();
            
            if (response.ok) {
                // Update the element with new name
                element.innerHTML = newName;
                element.dataset.currentName = newName;
                showAlert('Name updated successfully!', 'success');
                
                // Update the instance name in the global instanceItems array
                const instance = instanceItems.find(inst => inst.id == inventoryId);
                if (instance) {
                    instance.instance_name = newName;
                }
                
                // Update currentlySelectedInstance if this was the selected one
                if (currentlySelectedInstance === currentName) {
                    currentlySelectedInstance = newName;
                }
                
                // Refresh the instances display to update all references
                displayInstances(instanceItems, currentSetNumber);
            } else {
                showAlert(data.error || 'Failed to update name', 'danger');
                cancel();
            }
        } catch (error) {
            console.error('Error updating name:', error);
            showAlert('An error occurred while updating the name', 'danger');
            cancel();
        }
    };
    
    // Cancel function
    const cancel = () => {
        element.innerHTML = originalContent;
    };
    
    // Event listeners
    saveBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        save();
    });
    cancelBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        cancel();
    });
    
    input.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            save();
        } else if (e.key === 'Escape') {
            e.preventDefault();
            cancel();
        }
    });
    
    // Click outside to cancel
    const clickOutside = (e) => {
        if (!element.contains(e.target)) {
            cancel();
            document.removeEventListener('click', clickOutside);
        }
    };
    
    // Add event listener after a short delay to prevent immediate cancellation
    setTimeout(() => {
        document.addEventListener('click', clickOutside);
    }, 100);
}

function showAlert(message, type) {
    // Get or create toast container
    let toastContainer = document.getElementById('toastContainer');
    if (!toastContainer) {
        toastContainer = document.createElement('div');
        toastContainer.id = 'toastContainer';
        toastContainer.className = 'toast-container';
        document.body.appendChild(toastContainer);
    }
    
    // Create toast notification
    const toast = document.createElement('div');
    toast.className = `toast-notification ${type}`;
    
    // Set icon based on type
    let icon = 'fas fa-check-circle';
    switch(type) {
        case 'success':
            icon = 'fas fa-check-circle';
            break;
        case 'danger':
            icon = 'fas fa-exclamation-circle';
            break;
        case 'warning':
            icon = 'fas fa-exclamation-triangle';
            break;
        case 'info':
            icon = 'fas fa-info-circle';
            break;
    }
    
    toast.innerHTML = `
        <div class="toast-content">
            <i class="toast-icon ${icon}"></i>
            <span class="toast-message">${message}</span>
            <button class="toast-close" onclick="this.parentElement.parentElement.remove()">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="toast-progress" style="animation-duration: 3s;"></div>
    `;
    
    // Add to container
    toastContainer.appendChild(toast);
    
    // Auto-dismiss after 3 seconds
    setTimeout(() => {
        if (toast.parentNode) {
            toast.style.animation = 'slideDownOut 0.3s ease-out';
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.remove();
                }
            }, 300);
        }
    }, 3000);
}

async function selectInstance(setNumber, instanceName) {
    // Do nothing if the currently selected instance is clicked
    if (currentlySelectedInstance === instanceName) {
        return;
    }
    
    // If switching to a different instance, hide current inventory first
    if (currentlySelectedInstance && currentlySelectedInstance !== instanceName) {
        // Auto-save handles changes automatically
    }

    // Set the current instance index for arrow key navigation
    // updateInstanceItems();
    currentInstanceIndex = instanceItems.findIndex(item => item.instance_name === instanceName);
    
    // Set current instance for inventory modifications
    currentInstanceName = instanceName;
    currentlySelectedInstance = instanceName;
    
    // Update the instance selection display to show the selected instance
    updateInstanceSelectionDisplay(setNumber, instanceName);
    
    try {
        const response = await fetch('/view_instance_inventory', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                set_number: setNumber,
                instance_name: instanceName
            })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            // Load and display inventory with instance-specific modifications
            await loadModifiedInventory(setNumber, instanceName);
            displayInventory(data.inventory);
            
            // Refresh color filter buttons to show current selection state
            refreshColorFilterButtons();
            
            // Load and display the instance description
            await loadInstanceDescription(setNumber, instanceName);
        } else {
            showAlert(data.error || 'Failed to load instance inventory', 'danger');
        }
    } catch (error) {
        console.error('Error selecting instance:', error);
        showAlert('An error occurred while loading the instance', 'danger');
    } finally {
    }
}


function showInstanceSelectionScreen() {
    // Hide inventory and show instance selection
    document.getElementById('inventoryContainer').style.display = 'none';
    document.getElementById('instanceSelectionSection').style.display = 'block';
}

async function addNewInstance() {
    const setNumber = currentSetNumber;
    const setTitle = document.getElementById('setTitle').textContent.replace(' Set Information', '').replace(' ', '');
    let instanceName = document.getElementById('newInstanceName').value.trim();
    
    if (!instanceName) {
        showAlert('Please enter an instance name', 'warning');
        return;
    }
    
    if (!setNumber) {
        showAlert('No set selected', 'error');
        return;
    }
    
    // Get existing instances to check for duplicates
    const existingInstances = await getInstances(setNumber);
    const existingNames = existingInstances.map(instance => instance.instance_name);
    
    // Generate a unique name if the current name already exists
    const originalName = instanceName;
    while (existingNames.includes(instanceName)) {
        const lastChar = instanceName.slice(-1);
        if (/\d/.test(lastChar)) {
            // Last character is a digit, increment it
            const baseName = instanceName.slice(0, -1);
            const lastDigit = parseInt(lastChar);
            instanceName = baseName + (lastDigit + 1);
        } else {
            // Last character is not a digit, add "0" to the end
            instanceName = instanceName + '0';
        }
    }
    
    // Update the input field if the name was changed
    if (instanceName !== originalName) {
        document.getElementById('newInstanceName').value = instanceName;
        showAlert(`Instance name changed to "${instanceName}" to avoid duplicate`, 'info');
    }
    
    try {
        const response = await fetch('/add_to_collection', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                set_number: setNumber,
                set_name: setTitle,
                instance_name: instanceName
            })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            showAlert('New set instance added successfully!', 'success');
            
            // Add the new instance to the display
            const newInstance = {
                id: data.owned_set_id,
                instance_name: instanceName,
                added_at: new Date().toISOString()
            };
            addInstanceToDisplay(newInstance, setNumber);
            
            // Automatically select the newly added instance
            await selectInstance(setNumber, instanceName);
            
        } else {
            if (data.login_required) {
                showAlert('Please log in to add sets to your collection', 'warning');
                // Optionally redirect to login page
                setTimeout(() => {
                    window.location.href = '/login';
                }, 2000);
            } else {
                showAlertNear(data.error || 'Failed to add set to collection', 'danger', '#instanceSelectionSection');
            }
        }
    } catch (error) {
        console.error('Error adding to collection:', error);
        showAlertNear('An error occurred while adding to collection', 'danger', '#instanceSelectionSection');
    }
}


function viewInstance(setNumber, instanceName) {
    // For now, just show an alert. In the future, this could open a modal or navigate to a specific view
    showAlert(`Viewing instance: ${instanceName} of set ${setNumber}`, 'info');
}

async function deleteSetInstance(owned_set_id, instanceName) {
    // Check if user has chosen to skip confirmation
    if (!shouldSkipDeleteConfirmation()) {
        const confirmed = await showDeleteConfirmation(instanceName, 'This will also delete all inventory modifications for this instance.');
        if (!confirmed) {
            return;
        }
    }
    
    try {
        const response = await fetch('/delete_set_instance', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                owned_set_id: owned_set_id
            })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            showAlert('Set instance deleted successfully!', 'success');
            
            // Check if the deleted instance was the currently viewed one
            // const deletedInstanceName = instanceName;
            // if (currentlySelectedInstance === deletedInstanceName) {
            //     // Hide inventory and reset selection
            //     document.getElementById('inventoryContainer').style.display = 'none';
            //     currentlySelectedInstance = null;
            //     currentInstanceName = 'Default';
            //     Auto-save handles changes automatically
            // }
            
            // Remove the deleted instance from the DOM
            removeInstanceFromDisplay(instanceName);
        } else {
            showAlert(data.error || 'Failed to delete set instance', 'danger');
        }
    } catch (error) {
        console.error('Error deleting set instance:', error);
        showAlert('An error occurred while deleting the set instance', 'danger');
    }
}


// saveInventory function removed - auto-save is now implemented

// Initialize instruction cache when page loads
loadInstructionCache();
</script>
{% endblock %}

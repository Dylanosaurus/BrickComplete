{% extends "base.html" %}

{% block title %}BrickComplete - LEGO Set Inventory Manager{% endblock %}

{% block content %}
<div class="row">
    <div class="col-12">
        <div class="jumbotron bg-light p-5 rounded mb-4">
            <h1 class="display-4">
                <i class="fas fa-cube text-danger"></i> BrickComplete
            </h1>
            <p class="lead">Search for LEGO sets and manage your inventory with ease!</p>
            <hr class="my-4">
            <p>Enter a LEGO set number to view its inventory and modify quantities for your collection.</p>
        </div>
    </div>
</div>

<div class="row">
    <div class="col-md-6">
        <div class="card">
            <div class="card-header">
                <h5><i class="fas fa-search"></i> Search LEGO Set</h5>
            </div>
            <div class="card-body">
                <form id="searchForm" autocomplete="off">
                    <div class="mb-3">
                        <label for="setNumber" class="form-label">Set Number</label>
                        <input type="text" class="form-control" id="setNumber" placeholder="e.g., 10265-1" autocomplete="off" required>
                        <div class="form-text">Enter the LEGO set number (format: 10265-1)</div>
                        <div id="setSuggestions" class="mt-2" style="display: none;">
                            <small class="text-muted">Suggestions:</small>
                            <div id="suggestionList" class="mt-1"></div>
                        </div>
                    </div>
                    <button type="submit" class="btn btn-lego">
                        <i class="fas fa-search"></i> Search Set
                    </button>
                </form>
            </div>
        </div>
    </div>
    
    <div class="col-md-6">
        <div class="card" id="howItWorks">
            <div class="card-header">
                <h5><i class="fas fa-info-circle"></i> How it Works</h5>
            </div>
            <div class="card-body">
                <ol>
                    <li>Enter a LEGO set number in the search box</li>
                    <li>View the complete inventory of parts</li>
                    <li>Use + and - buttons to modify quantities</li>
                    <li>Your changes are automatically saved to your account</li>
                </ol>
                {% if not current_user.is_authenticated %}
                <div class="alert alert-warning mt-3">
                    <i class="fas fa-exclamation-triangle"></i>
                    <strong>Login required!</strong> You need to be logged in to save inventory modifications.
                </div>
                {% endif %}
            </div>
        </div>
        <div class="card" id="setInfo" style="display: none;">
            <div class="card-header d-flex justify-content-between align-items-center" style="height: 120px;">
                  <h5 id="setTitle"><i class="fas fa-cube"></i> Set Information</h5>
                  <div class="d-flex flex-column align-items-end gap-2">
                      <button id="legoInstructionsBtn" class="btn btn-outline-primary" onclick="openLegoInstructions()" style="display: none;">
                          <i class="fas fa-external-link-alt"></i> Lego Instructions
                      </button>
                      <button id="buildingInstructionsBtn" class="btn btn-outline-info" onclick="openBuildingInstructions()" style="display: none;">
                          <i class="fas fa-book"></i> BrickInstructions
                      </button>
                    <button class="btn btn-success" id="saveInventory" style="display: none;">
                        <i class="fas fa-save"></i> Save Changes
                    </button>
                </div>
            </div>
            <div class="card-body" style="height: 404px;">
                <div id="setDetails"></div>
            </div>
        </div>
    </div>
</div>



<div id="instanceSelectionSection" class="row mt-4" style="display: none;">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <h5><i class="fas fa-list"></i> Select Set Instance</h5>
            </div>
            <div class="card-body">
                <p class="text-muted" id="instanceSelectionText">You have existing instances of this set. Choose which one to view or add a new instance:</p>
                <div id="instanceSelectionList" class="mb-3"></div>
                <div class="row">
                    <div class="col-md-8">
                        <div class="input-group">
                            <span class="input-group-text"><i class="fas fa-tag"></i></span>
                            <input type="text" class="form-control" id="newInstanceName" placeholder="Enter new instance name (e.g., 'Built Set', 'Spare Parts')" value="Default" autocomplete="off">
                        </div>
                        <div class="form-text">Give this new set instance a unique name</div>
                    </div>
                    <div class="col-md-4">
                        <button class="btn btn-success w-100" id="addNewInstanceBtn" onclick="addNewInstance()">
                            <i class="fas fa-plus"></i> Add New Instance
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="inventoryContainer" class="row mt-4" style="display: none;">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h5><i class="fas fa-list"></i> Set Inventory</h5>
                    <button id="saveInventoryBtn" class="btn btn-success" onclick="saveInventory()" style="display: none;">
                        <i class="fas fa-save"></i> Save Changes
                    </button>
                </div>
            </div>
            <div id="colorFilterPanel" class="card-body" style="border-bottom: 1px solid #dee2e6;">
                <h6 class="mb-3"><i class="fas fa-palette"></i> Filter by Color</h6>
                <div id="colorFilterButtons" class="d-flex flex-wrap gap-2">
                    <!-- Color filter buttons will be dynamically generated here -->
                </div>
                <div class="mt-3">
                    <button class="btn btn-sm btn-outline-secondary" onclick="clearColorFilter()">
                        <i class="fas fa-times"></i> Clear All Filters
                    </button>
                </div>
            </div>
            <div class="card-body">
                <div id="inventoryList"></div>
            </div>
        </div>
    </div>
</div>

<div id="loadingSpinner" class="text-center mt-4" style="display: none;">
    <div class="spinner-border text-danger" role="status">
        <span class="visually-hidden">Loading...</span>
    </div>
    <p class="mt-2">Loading set information...</p>
</div>

<!-- Instruction Images Modal -->
<div class="modal fade" id="instructionModal" tabindex="-1" aria-labelledby="instructionModalLabel">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                       <h5 class="modal-title" id="instructionModalLabel">
                           <i class="fas fa-book"></i> BrickInstructions
                       </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div id="instructionImages" class="text-center">
                    <!-- Instruction images will be loaded here -->
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="{{ url_for('static', filename='js/common.js') }}"></script>
<script>
let modifiedInventory = {};
let currentInstanceName = 'Default';
let hasUnsavedChanges = false;
let currentlySelectedInstance = null;
let originalInventoryMap = {};

// Recent searches functionality
const RECENT_SEARCHES_KEY = 'brickcomplete_recent_searches';
const MAX_RECENT_SEARCHES = 5;

// Instruction availability cache functionality
const INSTRUCTION_CACHE_KEY = 'brickcomplete_instruction_cache';
const MAX_CACHED_SETS = 20;
let instructionCache = {}; // Global cache variable

function getRecentSearches() {
    try {
        const stored = localStorage.getItem(RECENT_SEARCHES_KEY);
        return stored ? JSON.parse(stored) : [];
    } catch (error) {
        console.error('Error loading recent searches:', error);
        return [];
    }
}

function saveRecentSearches(searches) {
    try {
        localStorage.setItem(RECENT_SEARCHES_KEY, JSON.stringify(searches));
    } catch (error) {
        console.error('Error saving recent searches:', error);
    }
}

function addToRecentSearches(setNumber, setName) {
    const recentSearches = getRecentSearches();
    
    // Remove if already exists
    const existingIndex = recentSearches.findIndex(item => item.setNumber === setNumber);
    if (existingIndex !== -1) {
        recentSearches.splice(existingIndex, 1);
    }
    
    // Add to beginning
    recentSearches.unshift({
        setNumber: setNumber,
        setName: setName,
        timestamp: new Date().toISOString()
    });
    
    // Keep only the most recent searches
    if (recentSearches.length > MAX_RECENT_SEARCHES) {
        recentSearches.splice(MAX_RECENT_SEARCHES);
    }
    
    saveRecentSearches(recentSearches);
    
    // Refresh recent search suggestions
    loadRecentSearchSuggestions();
}

// Instruction availability cache functions
function loadInstructionCache() {
    try {
        const stored = localStorage.getItem(INSTRUCTION_CACHE_KEY);
        instructionCache = stored ? JSON.parse(stored) : {};
    } catch (error) {
        console.error('Error loading instruction cache:', error);
        instructionCache = {};
    }
}

function saveInstructionCache() {
    try {
        localStorage.setItem(INSTRUCTION_CACHE_KEY, JSON.stringify(instructionCache));
    } catch (error) {
        console.error('Error saving instruction cache:', error);
    }
}

function getCachedInstructionAvailability(setNumber) {
    return instructionCache[setNumber] || null;
}

function setCachedInstructionAvailability(setNumber, legoAvailable, brickAvailable) {
    // Add new entry to global cache
    instructionCache[setNumber] = {
        lego: legoAvailable,
        brick: brickAvailable,
        timestamp: Date.now()
    };
    
    // Keep only the most recent entries
    const entries = Object.entries(instructionCache);
    if (entries.length > MAX_CACHED_SETS) {
        // Sort by timestamp and keep only the most recent
        entries.sort((a, b) => b[1].timestamp - a[1].timestamp);
        const recentEntries = entries.slice(0, MAX_CACHED_SETS);
        
        // Rebuild global cache with only recent entries
        const newCache = {};
        recentEntries.forEach(([setNum, data]) => {
            newCache[setNum] = data;
        });
        instructionCache = newCache;
    }
    
    // Save to localStorage
    saveInstructionCache();
}

document.getElementById('searchForm').addEventListener('submit', function(e) {
    e.preventDefault();
    const setNumber = document.getElementById('setNumber').value.trim();
    if (setNumber) {
        searchSet(setNumber);
    }
});

// Add input event listener for set number suggestions
document.getElementById('setNumber').addEventListener('input', function(e) {
    const value = e.target.value.trim();
    showSuggestions(value);
});

// Add focus event listener to show recent searches when input is focused and empty
document.getElementById('setNumber').addEventListener('focus', function(e) {
    const value = e.target.value.trim();
    if (value.length === 0) {
        showSuggestions('');
    }
});

// Add keyboard navigation for set number input
document.getElementById('setNumber').addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
        e.preventDefault();
        // If a suggestion is highlighted, use that; otherwise use the first suggestion if available, or the input value
        let setNumber;
        if (currentSuggestionIndex >= 0 && currentSuggestionIndex < suggestionItems.length) {
            const highlightedItem = suggestionItems[currentSuggestionIndex];
            // Extract set number from the suggestion item
            setNumber = extractSetNumberFromSuggestion(highlightedItem);
        } else if (suggestionItems.length > 0) {
            // Auto-select the first suggestion if no suggestion is highlighted
            setNumber = extractSetNumberFromSuggestion(suggestionItems[0]);
        } else {
            setNumber = e.target.value.trim();
        }
        if (setNumber) {
            searchSet(setNumber);
            // hideSetSuggestions();
        }
    } else if (e.key === 'Escape') {
        hideSetSuggestions();
    } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        navigateSuggestions(1);
    } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        navigateSuggestions(-1);
    }
});

// Add Enter key support for new instance name input
document.getElementById('newInstanceName').addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
        e.preventDefault();
        addNewInstance();
    }
});

// Set suggestions are now fetched from the database

// Global variables for suggestion navigation
let currentSuggestionIndex = -1;
let suggestionItems = [];
let allSuggestions = []; // Store all suggestions (recent + autofill)
let recentSearchSuggestions = []; // Store recent search suggestions
let autofillSuggestions = []; // Store autofill suggestions

// Global variables for instance navigation
let currentInstanceIndex = -1;
let instanceItems = [];
let navigationInstance = false;

function extractSetNumberFromSuggestion(suggestionItem) {
    // For recent search suggestions, extract the set number from the HTML structure
    const setNumberSpan = suggestionItem.querySelector('span');
    if (setNumberSpan) {
        // Remove the icon and get just the set number
        return setNumberSpan.textContent.replace(/^[^\w]*/, '').trim();
    }
    // Fallback to textContent for autofill suggestions
    return suggestionItem.textContent.trim();
}

function createRecentSearchSuggestion(search) {
    const suggestionItem = document.createElement('div');
    suggestionItem.className = 'suggestion-item p-2 border rounded mb-1 cursor-pointer bg-light';
    suggestionItem.style.cursor = 'pointer';
    suggestionItem.id = `suggestion-${search.setNumber}`;
    suggestionItem.innerHTML = `
        <div class="d-flex justify-content-between align-items-center">
            <span><i class="fas fa-history me-2"></i>${search.setNumber}</span>
            <small class="text-muted">${search.setName}</small>
        </div>
    `;
    suggestionItem.addEventListener('click', function() {
        hideSetSuggestions();
        searchSet(search.setNumber);
    });
    return suggestionItem;
}

function createAutofillSuggestion(setData) {
    const suggestionItem = document.createElement('div');
    suggestionItem.className = 'suggestion-item p-2 border rounded mb-1 cursor-pointer bg-light';
    suggestionItem.style.cursor = 'pointer';
    suggestionItem.id = `suggestion-${setData.set_number}`;
    suggestionItem.innerHTML = `
        <div class="d-flex justify-content-between align-items-center">
            <span><i class="fas fa-search me-2"></i>${setData.set_number}</span>
            <small class="text-muted">${setData.set_name}</small>
        </div>
    `;
    suggestionItem.addEventListener('click', function() {
        document.getElementById('setNumber').value = setData.set_number;
        hideSetSuggestions();
        searchSet(setData.set_number);
    });
    return suggestionItem;
}

function loadRecentSearchSuggestions() {
    const recentSearches = getRecentSearches();
    recentSearchSuggestions = recentSearches.map(search => createRecentSearchSuggestion(search));
}

async function loadAutofillSuggestions(query) {
    if (query.length < 2) {
        autofillSuggestions = [];
        return;
    }
    
    try {
        const response = await fetch(`/get_set_suggestions?q=${encodeURIComponent(query)}&limit=10`);
        if (response.ok) {
            const suggestions = await response.json();
            autofillSuggestions = suggestions.map(setData => createAutofillSuggestion(setData));
        } else {
            autofillSuggestions = [];
        }
    } catch (error) {
        console.error('Error fetching autofill suggestions:', error);
        autofillSuggestions = [];
    }
}

function filterAndDisplaySuggestions(input) {
    const suggestionList = document.getElementById('suggestionList');
    const suggestionContainer = document.getElementById('setSuggestions');
    
    // Unhighlight any previously highlighted suggestions
    if (suggestionItems.length > 0) {
        suggestionItems.forEach(item => {
            item.classList.remove('bg-primary', 'text-white');
            item.classList.add('bg-light');
            // Reset set name text color
            const setNameElement = item.querySelector('small');
            if (setNameElement) {
                setNameElement.classList.remove('text-white');
                setNameElement.classList.add('text-muted');
            }
        });
    }
    
    // Clear current display
    suggestionList.innerHTML = '';
    suggestionItems = [];
    currentSuggestionIndex = -1;
    
    let filteredSuggestions = [];
    
    if (input.length === 0) {
        // Show all recent searches when input is empty
        filteredSuggestions = recentSearchSuggestions.slice(0, 5);
    } else {
        // Filter suggestions based on input
        const query = input.toLowerCase();
        
        // Filter recent searches
        const filteredRecent = recentSearchSuggestions.filter(item => {
            const setNumber = item.querySelector('span').textContent.replace(/^[^\w]*/, '').trim();
            return setNumber.toLowerCase().startsWith(query);
        });
        
        // Filter autofill suggestions, excluding those that are already in recent searches
        const recentSetNumbers = new Set(filteredRecent.map(item => {
            return item.querySelector('span').textContent.replace(/^[^\w]*/, '').trim();
        }));
        
        const filteredAutofill = autofillSuggestions.filter(item => {
            const setNumber = item.querySelector('span').textContent.replace(/^[^\w]*/, '').trim();
            return setNumber.toLowerCase().startsWith(query) && !recentSetNumbers.has(setNumber);
        });
        
        // Combine recent searches first (priority), then autofill, limit to 5 total
        filteredSuggestions = [...filteredRecent, ...filteredAutofill].slice(0, 5);
    }
    
    // Display filtered suggestions
    if (filteredSuggestions.length > 0) {
        filteredSuggestions.forEach(suggestion => {
            suggestionList.appendChild(suggestion);
            suggestionItems.push(suggestion);
        });
        suggestionContainer.style.display = 'block';
    } else {
        suggestionContainer.style.display = 'none';
    }
}

function navigateSuggestions(direction) {
    const suggestionContainer = document.getElementById('setSuggestions');
    if (suggestionContainer.style.display === 'none' || suggestionItems.length === 0) {
        return;
    }
    
    // Update the current index
    currentSuggestionIndex += direction;
    
    // Wrap around if needed
    if (currentSuggestionIndex < 0) {
        currentSuggestionIndex = suggestionItems.length - 1;
    } else if (currentSuggestionIndex >= suggestionItems.length) {
        currentSuggestionIndex = 0;
    }
    
    // Remove highlight from all items
    suggestionItems.forEach(item => {
        item.classList.remove('bg-primary', 'text-white');
        item.classList.add('bg-light');
        // Reset set name text color
        const setNameElement = item.querySelector('small');
        if (setNameElement) {
            setNameElement.classList.remove('text-white');
            setNameElement.classList.add('text-muted');
        }
    });
    
    // Highlight the current item
    if (currentSuggestionIndex >= 0 && currentSuggestionIndex < suggestionItems.length) {
        const currentItem = suggestionItems[currentSuggestionIndex];
        currentItem.classList.remove('bg-light');
        currentItem.classList.add('bg-primary', 'text-white');
        
        // Make set name text white when highlighted
        const setNameElement = currentItem.querySelector('small');
        if (setNameElement) {
            setNameElement.classList.remove('text-muted');
            setNameElement.classList.add('text-white');
        }
        
        // Update the input field with just the set number from the selected suggestion
        const setNumberInput = document.getElementById('setNumber');
        setNumberInput.value = extractSetNumberFromSuggestion(currentItem);
    }
}

async function showSuggestions(input) {
    // Load recent search suggestions if not already loaded
    if (recentSearchSuggestions.length === 0) {
        loadRecentSearchSuggestions();
    }
    
    // Load autofill suggestions if user is typing
    if (input.length >= 2) {
        await loadAutofillSuggestions(input);
    } else {
        autofillSuggestions = [];
    }
    
    // Filter and display suggestions
    filterAndDisplaySuggestions(input);
}

function hideSetSuggestions() {
    // document.getElementById('setSuggestions').style.display = 'none';
    // Reset navigation state
    // currentSuggestionIndex = -1;
    // suggestionItems = [];
}

// // Instance navigation functions
// function updateInstanceItems() {
//     const instanceSelectionList = document.getElementById('instanceSelectionList');
//     if (instanceSelectionList) {
//         instanceItems = Array.from(instanceSelectionList.querySelectorAll('div[onclick*="instanceClicked"]'));
//     }
// }

function navigateInstances(direction) {
    if (!navigationInstance) {
        return;
    }
    const instanceSelectionSection = document.getElementById('instanceSelectionSection');
    if (instanceSelectionSection.style.display === 'none' || instanceItems.length === 0) {
        return;
    }
    
    // Update the current index
    currentInstanceIndex += direction;
    
    // Wrap around if needed
    if (currentInstanceIndex < 0) {
        currentInstanceIndex = instanceItems.length - 1;
    } else if (currentInstanceIndex >= instanceItems.length) {
        currentInstanceIndex = 0;
    }
    
    // Call selectInstance with the current instance
    if (currentInstanceIndex >= 0 && currentInstanceIndex < instanceItems.length) {
        const currentItem = instanceItems[currentInstanceIndex].instance_name;
        selectInstance(currentSetNumber, currentItem);
    }
}

function resetInstanceNavigation() {
    // currentInstanceIndex = -1;
    // instanceItems = [];
    navigationInstance = false;
}

// Hide suggestions when clicking outside
document.addEventListener('click', function(e) {
    const setNumberInput = document.getElementById('setNumber');
    const suggestions = document.getElementById('setSuggestions');
    
    if (!setNumberInput.contains(e.target) && !suggestions.contains(e.target)) {
        hideSetSuggestions();
    }
    
    // Reset instance navigation when clicking outside instance selection
    const instanceSelectionSection = document.getElementById('instanceSelectionSection');
    if (instanceSelectionSection && !instanceSelectionSection.contains(e.target)) {
        resetInstanceNavigation();
    }
});

// Global keyboard navigation for instances
document.addEventListener('keydown', function(e) {
    // Only handle arrow keys when instance selection section is visible and has instances
    const instanceSelectionSection = document.getElementById('instanceSelectionSection');
    if (instanceSelectionSection && instanceSelectionSection.style.display !== 'none' && instanceItems.length > 0) {
        if (e.key === 'ArrowUp') {
            e.preventDefault();
            navigateInstances(-1);
        } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            navigateInstances(1);
        }
    }
});

async function searchSet(setNumber) {
    currentSetNumber = setNumber;
    currentlySelectedInstance = null; // Reset selected instance for new search
    
    // Hide previous results and show loading
    document.getElementById('howItWorks').style.display = 'none';
    // document.getElementById('instanceSelectionSection').style.display = 'none';
    document.getElementById('inventoryContainer').style.display = 'none';
    
    // Hide instruction buttons and show loading state
    document.getElementById('buildingInstructionsBtn').style.display = 'none';
    document.getElementById('legoInstructionsBtn').style.display = 'none';
    
    try {
        const response = await fetch('/search_set', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ set_number: setNumber })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            displaySetInfo(data);
            // Add to recent searches
            addToRecentSearches(setNumber, data.set_name);
            // Clear the search bar after successful search
            document.getElementById('setNumber').value = '';
            // showSuggestions('');
            // hideSetSuggestions();
            // Don't load inventory here - let displaySetInfo handle instance selection first
        } else {
            showAlert(data.error || 'Failed to fetch set information', 'danger');
        }
    } catch (error) {
        showAlert('Network error: ' + error.message, 'danger');
    } finally {
    }
}

async function displaySetInfo(data) {
    // First, show basic set info without external calls
    document.getElementById('setTitle').innerHTML = 
        `<i class="fas fa-cube"></i> ${data.set_name}`;
    
    // Create basic set details HTML (without image initially)
    let setDetailsHTML = `
        <div class="row">
            <div class="col-md-6">
                <strong>Set Number:</strong> ${data.set_number}
            </div>
            <div class="col-md-6">
                <strong>Total Parts:</strong> ${data.num_parts || data.inventory.length}
            </div>
        </div>
    `;
    
    // Add year if available
    if (data.year) {
        setDetailsHTML += `
            <div class="row mt-2">
                <div class="col-md-6">
                    <strong>Year:</strong> ${data.year}
                </div>
            </div>
        `;
    }
    
    // Show basic set info immediately
    document.getElementById('setDetails').innerHTML = setDetailsHTML;
    document.getElementById('setInfo').style.display = 'block';
    
    // Load instances first (fast, local database calls)
    instanceItems = await getInstances(data.set_number);
    displayInstances(instanceItems, data.set_number);
    if (instanceItems.length > 0) {
        selectInstance(data.set_number, instanceItems[0].instance_name);
    }
    document.getElementById('instanceSelectionSection').style.display = 'block';
    
    // Load set image and building instructions in the background (slow, external calls)
    loadSetImageAndInstructions(data);
}

async function loadSetImageAndInstructions(data) {
    // Add set image if available
    if (data.set_image) {
        const bricklinkUrl = `https://img.bricklink.com/ItemImage/SN/0/${data.set_number}.png`;
        const imageHTML = data.set_url ? 
            `<a href="${data.set_url}" target="_blank" rel="noopener noreferrer" title="View set on official website">
                <img src="${data.set_image}" 
                     alt="${data.set_name}" 
                     class="img-fluid rounded shadow-sm" 
                     style="max-height: 300px; max-width: 100%; cursor: pointer;"
                     onerror="this.src='${bricklinkUrl}'; this.onerror=function(){this.style.display='none'; this.nextElementSibling.style.display='block';};">
            </a>` :
            `<img src="${data.set_image}" 
                 alt="${data.set_name}" 
                 class="img-fluid rounded shadow-sm" 
                 style="max-height: 300px; max-width: 100%;"
                 onerror="this.src='${bricklinkUrl}'; this.onerror=function(){this.style.display='none'; this.nextElementSibling.style.display='block';};">`;
            
        const imageSection = `
            <div class="row mt-3">
                <div class="col-12 text-center">
                    ${imageHTML}
                </div>
            </div>
        `;
        
        // Append image to existing set details
        document.getElementById('setDetails').innerHTML += imageSection;
    } else {
        // If no set image, try BrickLink directly
        const bricklinkUrl = `https://img.bricklink.com/ItemImage/SN/0/${data.set_number}.png`;
        const imageSection = `
            <div class="row mt-3">
                <div class="col-12 text-center">
                    <img src="${bricklinkUrl}" 
                         alt="${data.set_name}" 
                         class="img-fluid rounded shadow-sm" 
                         style="max-height: 300px; max-width: 100%;"
                         onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                </div>
            </div>
        `;
        
        // Append image to existing set details
        document.getElementById('setDetails').innerHTML += imageSection;
    }
    
    // Check if building instructions exist (slow external call)
    await checkBuildingInstructionsAvailability(data.set_number);
}

function displayInventory(inventory) {
    const container = document.getElementById('inventoryList');
    const colorFilterPanel = document.getElementById('colorFilterPanel');
    container.innerHTML = '';
    
    // Reset unsaved changes and hide save button initially
    hasUnsavedChanges = false;
    document.getElementById('saveInventoryBtn').style.display = 'none';
    
    // Reset color filter
    selectedColors.clear();
    
    // Check if inventory is empty
    if (!inventory || inventory.length === 0) {
        // Show only the card header and a "no parts" message
        colorFilterPanel.style.display = 'none';
        container.innerHTML = `
            <div class="text-center py-5">
                <i class="fas fa-inbox fa-3x text-muted mb-3"></i>
                <h5 class="text-muted">This set contains no parts</h5>
                <p class="text-muted">No inventory data is available for this set.</p>
            </div>
        `;
        document.getElementById('inventoryContainer').style.display = 'block';
        return;
    }
    
    // Show color filter panel for sets with parts
    colorFilterPanel.style.display = 'block';
    
    // Generate color filter buttons
    generateColorFilterButtons(inventory);
    
    // Create a map of original inventory for quick lookup and store globally
    originalInventoryMap = {};
    inventory.forEach(part => {
        // Include category information in the key to keep parts separate
        const key = `${part.part_number}_${part.color_id}_${part.is_spare ? 'spare' : 'regular'}_${part.is_minifig_part ? 'minifig' : 'normal'}`;
        originalInventoryMap[key] = part;
    });
    
    // Separate parts by type and spare status using the new is_minifig_part field
    const regularParts = inventory.filter(part => !part.is_spare && !part.is_minifig_part);
    const minifigParts = inventory.filter(part => !part.is_spare && part.is_minifig_part);
    const spareParts = inventory.filter(part => part.is_spare);
    
    // Sort regular parts to put "No Color/Any Color" (color ID 9999) at the top
    regularParts.sort((a, b) => {
        const aIsNoColor = a.color_id === 9999 || a.color_name === 'No Color' || a.color_name === 'Any Color';
        const bIsNoColor = b.color_id === 9999 || b.color_name === 'No Color' || b.color_name === 'Any Color';
        
        if (aIsNoColor && !bIsNoColor) return -1;
        if (!aIsNoColor && bIsNoColor) return 1;
        
        // If both are no color or both are regular colors, maintain existing sort order
        return 0;
    });
    
    // Display regular parts
    if (regularParts.length > 0) {
        const regularSection = document.createElement('div');
        regularSection.innerHTML = `
            <h6 class="mb-3"><i class="fas fa-cube"></i> Regular Parts (${regularParts.length})</h6>
        `;
        container.appendChild(regularSection);
        
        regularParts.forEach(part => {
            const partCard = createPartCard(part, originalInventoryMap);
            container.appendChild(partCard);
        });
    }
    
    // Display minifig parts
    if (minifigParts.length > 0) {
        const minifigSection = document.createElement('div');
        minifigSection.innerHTML = `
            <hr class="my-4">
            <h6 class="mb-3"><i class="fas fa-user"></i> Minifig Parts (${minifigParts.length})</h6>
        `;
        container.appendChild(minifigSection);
        
        minifigParts.forEach(part => {
            const partCard = createPartCard(part, originalInventoryMap);
            container.appendChild(partCard);
        });
    }
    
    // Display spare parts
    if (spareParts.length > 0) {
        const spareSection = document.createElement('div');
        spareSection.innerHTML = `
            <hr class="my-4">
            <h6 class="mb-3"><i class="fas fa-gift"></i> Spare Parts (${spareParts.length})</h6>
        `;
        container.appendChild(spareSection);
        
        spareParts.forEach(part => {
            const partCard = createPartCard(part, originalInventoryMap);
            container.appendChild(partCard);
        });
    }
    
    document.getElementById('inventoryContainer').style.display = 'block';
}

function getContrastColor(hexColor) {
    // Remove # if present
    hexColor = hexColor.replace('#', '');
    
    // Convert to RGB
    const r = parseInt(hexColor.substr(0, 2), 16);
    const g = parseInt(hexColor.substr(2, 2), 16);
    const b = parseInt(hexColor.substr(4, 2), 16);
    
    // Calculate brightness using luminance formula
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    
    // Return black for light colors, white for dark colors
    return brightness > 128 ? '#000000' : '#ffffff';
}

// Global variables for color filtering
let selectedColors = new Set();
let allInventoryParts = [];
let currentSetNumber = null;

async function checkBuildingInstructionsAvailability(setNumber) {
    // Remove the -digit suffix from the set number
    const cleanSetNumber = setNumber.replace(/-\d+$/, '');
    
    const legoBtn = document.getElementById('legoInstructionsBtn');
    const brickBtn = document.getElementById('buildingInstructionsBtn');
    
    // Set initial state - buttons are hidden but ready to show
    legoBtn.style.display = 'none';
    legoBtn.classList.remove('show');
    brickBtn.style.display = 'none';
    brickBtn.classList.remove('show');
    
    // Check cache first
    const cachedData = getCachedInstructionAvailability(cleanSetNumber);
    if (cachedData) {
        console.log('Using cached instruction availability for', cleanSetNumber);
        
        // Show buttons based on cached data
        if (cachedData.lego) {
            legoBtn.style.display = 'inline-block';
            setTimeout(() => {
                legoBtn.classList.add('show');
            }, 10);
        }
        
        if (cachedData.brick) {
            brickBtn.style.display = 'inline-block';
            setTimeout(() => {
                brickBtn.classList.add('show');
            }, 10);
        }
        
        return; // Exit early if we have cached data
    }
    
    console.log('No cache found, checking external sources for', cleanSetNumber);
    
    // Check LEGO instructions availability
    let legoAvailable = false;
    try {
        const legoResponse = await fetch('/check_instructions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ set_number: cleanSetNumber })
        });
        const legoResult = await legoResponse.json();
        legoAvailable = legoResult.has_instructions;
        
        if (legoAvailable) {
            legoBtn.style.display = 'inline-block';
            // Smooth fade in using CSS class
            setTimeout(() => {
                legoBtn.classList.add('show');
            }, 10);
        }
    } catch (error) {
        console.log('Could not verify LEGO instructions availability:', error);
    }
    
    // Check BrickInstructions availability
    let brickAvailable = false;
    try {
        // Check if instruction images are available from brickinstructions.com
        const response = await fetch('/get_instruction_images', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ set_number: cleanSetNumber })
        });
        
        const result = await response.json();
        brickAvailable = result.success && result.count > 1;
        
        if (brickAvailable) {
            brickBtn.style.display = 'inline-block';
            // Smooth fade in using CSS class
            setTimeout(() => {
                brickBtn.classList.add('show');
            }, 10);
        }
        
    } catch (error) {
        console.log('Could not verify building instructions availability:', error);
    }
    
    // Cache the results
    setCachedInstructionAvailability(cleanSetNumber, legoAvailable, brickAvailable);
}

async function openBuildingInstructions() {
    if (!currentSetNumber) {
        alert('No set selected');
        return;
    }
    
    // Remove the -digit suffix from the set number
    const cleanSetNumber = currentSetNumber.replace(/-\d+$/, '');
    
    try {
        // Show loading state
        const button = document.getElementById('buildingInstructionsBtn');
        const originalText = button.innerHTML;
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
        button.disabled = true;
        
        // Fetch instruction images
        const response = await fetch('/get_instruction_images', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ set_number: cleanSetNumber })
        });
        
        const result = await response.json();
        
        // Reset button state
        button.innerHTML = originalText;
        button.disabled = false;
        
        if (result.success) {
            // Show instruction images in a modal
            showInstructionModal(result.images, cleanSetNumber);
        } else {
            alert(`Could not load instructions: ${result.error}`);
        }
        
    } catch (error) {
        // Reset button state
        const button = document.getElementById('buildingInstructionsBtn');
        button.innerHTML = '<i class="fas fa-book"></i> BrickInstructions';
        button.disabled = false;
        
        alert('Error loading instructions: ' + error.message);
    }
}

function openLegoInstructions() {
    if (!currentSetNumber) {
        alert('No set selected');
        return;
    }
    
    const cleanSetNumber = currentSetNumber.replace(/-\d+$/, '');
    const legoUrl = `https://www.lego.com/en-us/service/building-instructions/${cleanSetNumber}`;
    
    // Open in a new tab
    window.open(legoUrl, '_blank');
}

function showInstructionModal(images, setNumber) {
    const modal = new bootstrap.Modal(document.getElementById('instructionModal'));
    const modalTitle = document.getElementById('instructionModalLabel');
    const imagesContainer = document.getElementById('instructionImages');
    
    // Update modal title with clickable link
    modalTitle.innerHTML = `<i class="fas fa-book"></i> <a href="https://lego.brickinstructions.com/lego_instructions/set/${setNumber}" target="_blank" class="text-decoration-none">BrickInstructions - Set ${setNumber}</a>`;
    
    // Clear previous images
    imagesContainer.innerHTML = '';
    
    if (images.length === 0) {
        imagesContainer.innerHTML = '<p class="text-muted">No instruction images found.</p>';
    } else {
        // Create image elements
        images.forEach((imageUrl, index) => {
            const img = document.createElement('img');
            img.src = imageUrl;
            img.className = 'img-fluid border rounded shadow-sm';
            img.style.maxWidth = '100%';
            img.style.height = 'auto';
            img.alt = `Instruction page ${index + 1}`;
            img.loading = 'lazy';
            
            imagesContainer.appendChild(img);
        });
    }
    
    // Show the modal
    modal.show();
}

function generateColorFilterButtons(inventory) {
    const colorButtonsContainer = document.getElementById('colorFilterButtons');
    colorButtonsContainer.innerHTML = '';
    
    // Get unique colors from inventory
    const uniqueColors = new Map();
    inventory.forEach(part => {
        const colorKey = `${part.color_id}_${part.color_name}`;
        if (!uniqueColors.has(colorKey)) {
            uniqueColors.set(colorKey, {
                color_id: part.color_id,
                color_name: part.color_name,
                color_rgb: part.color_rgb
            });
        }
    });
    
    // Sort colors by name
    const sortedColors = Array.from(uniqueColors.values()).sort((a, b) => a.color_name.localeCompare(b.color_name));
    
    // Create color filter buttons
    sortedColors.forEach(color => {
        const button = document.createElement('button');
        button.className = 'btn btn-sm color-filter-btn';
        button.style.cssText = `
            background-color: #${color.color_rgb};
            color: ${getContrastColor(color.color_rgb)};
            border: 1px solid #ccc;
            margin: 2px;
        `;
        button.textContent = color.color_name;
        button.onclick = () => toggleColorFilter(color.color_id);
        button.dataset.colorId = color.color_id;
        colorButtonsContainer.appendChild(button);
    });
}

function toggleColorFilter(colorId) {
    if (selectedColors.has(colorId)) {
        selectedColors.delete(colorId);
    } else {
        selectedColors.add(colorId);
    }
    
    // Update button appearance
    const buttons = document.querySelectorAll('.color-filter-btn');
    buttons.forEach(button => {
        const buttonColorId = parseInt(button.dataset.colorId);
        if (selectedColors.has(buttonColorId)) {
            button.style.border = '2px solid #007bff';
            button.style.boxShadow = '0 0 5px rgba(0, 123, 255, 0.5)';
        } else {
            button.style.border = '1px solid #ccc';
            button.style.boxShadow = 'none';
        }
    });
    
    // Apply filter
    applyColorFilter();
}

function clearColorFilter() {
    selectedColors.clear();
    
    // Reset button appearances
    const buttons = document.querySelectorAll('.color-filter-btn');
    buttons.forEach(button => {
        button.style.border = '1px solid #ccc';
        button.style.boxShadow = 'none';
    });
    
    // Show all parts
    applyColorFilter();
}

function applyColorFilter() {
    const container = document.getElementById('inventoryList');
    const partCards = container.querySelectorAll('.part-card');
    
    if (selectedColors.size === 0) {
        // Show all parts
        partCards.forEach(card => {
            card.style.display = 'block';
        });
    } else {
        // Filter parts by selected colors
        partCards.forEach(card => {
            const partKey = card.dataset.partKey;
            const part = originalInventoryMap[partKey];
            
            if (part && selectedColors.has(part.color_id)) {
                card.style.display = 'block';
            } else {
                card.style.display = 'none';
            }
        });
    }
}

function createPartCard(part, originalMap = {}) {
    // Generate part key that includes category information
    const partKey = `${part.part_number}_${part.color_id}_${part.is_spare ? 'spare' : 'regular'}_${part.is_minifig_part ? 'minifig' : 'normal'}`;
    const modifiedQty = modifiedInventory[partKey] || 0;
    
    // Get original quantity from the original inventory map
    const originalPart = originalMap[partKey];
    const originalQty = originalPart ? originalPart.quantity : part.quantity;
    const totalQty = originalQty + modifiedQty;
    
    // Calculate modification from original
    const modificationFromOriginal = totalQty - originalQty;
    
    const partCard = document.createElement('div');
    partCard.className = 'card part-card mb-3';
    partCard.dataset.partKey = partKey;
    partCard.innerHTML = `
        <div class="card-body">
            <div class="row align-items-center">
                <div class="col-md-2">
                    <div class="part-image-container">
                        <img src="${part.part_image_url || 'https://via.placeholder.com/60x60?text=No+Image'}" 
                             alt="${part.part_name}" 
                             class="part-image"
                             onerror="this.src='https://via.placeholder.com/60x60?text=No+Image'">
                    </div>
                </div>
                <div class="col-md-2">
                    <strong>${part.part_number}</strong><br>
                    <small class="text-muted">${part.part_name}</small>
                </div>
                <div class="col-md-2">
                    <span class="badge" style="background-color: #${part.color_rgb}; color: ${getContrastColor(part.color_rgb)}; border: 1px solid #ccc;">${part.color_name}</span>
                </div>
                <div class="col-md-2">
                    <small class="text-muted">Original:</small><br>
                    <strong>${originalQty}</strong>
                </div>
                <div class="col-md-3">
                    <div class="quantity-controls">
                        <button class="btn btn-outline-danger btn-sm" onclick="modifyQuantity('${partKey}', -1)" 
                                ${totalQty <= 0 ? 'disabled title="Cannot reduce below zero"' : ''}>
                            <i class="fas fa-minus"></i>
                        </button>
                        <span class="quantity-display" id="qty_${partKey}">${totalQty}</span>
                        <button class="btn btn-outline-success btn-sm" onclick="modifyQuantity('${partKey}', 1)">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                    <small class="modification-info" style="display: ${modificationFromOriginal !== 0 ? 'block' : 'none'};">Modified: ${modificationFromOriginal > 0 ? '+' : ''}${modificationFromOriginal}</small>
                </div>
                <div class="col-md-1">
                    ${part.is_spare ? '<span class="badge bg-warning">Spare</span>' : ''}
                </div>
            </div>
        </div>
    `;
    return partCard;
}

function modifyQuantity(partKey, change) {
    if (!currentSetNumber) return;
    
    // Get the original quantity from the original inventory map
    const originalPart = originalInventoryMap[partKey];
    const originalQty = originalPart ? originalPart.quantity : 0;

    // Update local state
    const previousModifiedQty = modifiedInventory[partKey] || 0;
    modifiedInventory[partKey] = previousModifiedQty + change;
    
    // Update the display without refreshing the entire inventory
    updateQuantityDisplay(partKey, originalQty, modifiedInventory[partKey]);
    
    // Mark as having unsaved changes and show save button
    hasUnsavedChanges = true;
    document.getElementById('saveInventoryBtn').style.display = 'block';
}

async function loadModifiedInventory(setNumber, instanceName = 'Default') {
    try {
        const response = await fetch(`/get_modified_inventory/${setNumber}?instance_name=${encodeURIComponent(instanceName)}`);
        if (response.ok) {
            modifiedInventory = await response.json();
        }
    } catch (error) {
        console.error('Failed to load modified inventory:', error);
    }
}

function showLoading(show) {
    const loadingElement = document.getElementById('loadingSpinner');
    if (show) {
        loadingElement.style.display = 'block';
        // Update loading message based on current action
        const loadingText = loadingElement.querySelector('p');
        if (loadingText) {
            loadingText.textContent = 'Loading set information...';
        }
    } else {
        loadingElement.style.display = 'none';
    }
}

function updateQuantityDisplay(partKey, originalQty, modifiedQty) {
    // Update the quantity display
    const qtyElement = document.getElementById(`qty_${partKey}`);
    if (qtyElement) {
        qtyElement.textContent = originalQty + modifiedQty;
    }
    
    // Update the modification info
    const partCard = qtyElement ? qtyElement.closest('.card') : null;
    if (partCard) {
        // Find the modification info element
        let modificationInfo = partCard.querySelector('.text-info');
        
        // If modification info element doesn't exist, create it
        if (!modificationInfo) {
            const quantityControls = partCard.querySelector('.quantity-controls');
            if (quantityControls) {
                modificationInfo = document.createElement('small');
                modificationInfo.className = 'text-info';
                modificationInfo.style.display = 'none';
                quantityControls.parentNode.appendChild(modificationInfo);
            }
        }
        
        if (modificationInfo) {
            const totalQty = originalQty + modifiedQty;
            const modificationFromOriginal = totalQty - originalQty;
            if (modificationFromOriginal !== 0) {
                modificationInfo.textContent = `Modified: ${modificationFromOriginal > 0 ? '+' : ''}${modificationFromOriginal}`;
                modificationInfo.style.display = 'block';
            } else {
                modificationInfo.style.display = 'none';
            }
        }
        
        // Update button states
        const minusButton = partCard.querySelector('.btn-outline-danger');
        if (minusButton) {
            const totalQty = originalQty + modifiedQty;
            if (totalQty <= 0) {
                minusButton.disabled = true;
                minusButton.title = "Cannot reduce below zero";
                minusButton.classList.add('disabled');
            } else {
                minusButton.disabled = false;
                minusButton.title = "";
                minusButton.classList.remove('disabled');
            }
        }
    }
}


// Collection management functions
async function getInstances(setNumber) {
    try {
        const response = await fetch(`/get_user_sets/${setNumber}`);
        
        if (!response.ok) {
            console.error(`Failed to load instances: ${response.status} ${response.statusText}`);
            return [];
        }
        
        const instances = await response.json();
        return instances;
    } catch (error) {
        console.error('Error loading existing instances:', error);
        return [];
    }
}

function displayInstances(instances, setNumber) {
    const instanceSelectionList = document.getElementById('instanceSelectionList');
    const instanceSelectionText = document.getElementById('instanceSelectionText');
    instanceSelectionList.innerHTML = '';
    
    // Update the descriptive text based on whether instances exist
    if (instances.length === 0) {
        instanceSelectionText.textContent = 'You don\'t have any instances of this set yet. Add your first instance below:';
    } else {
        instanceSelectionText.textContent = 'You have existing instances of this set. Choose which one to view or add a new instance:';
    }
    
    instances.forEach(instance => {
        const instanceDiv = document.createElement('div');
        
        // Check if this is the currently selected instance
        const isSelected = currentlySelectedInstance === instance.instance_name;
        
        // Apply different styling for selected vs unselected instances
        if (isSelected) {
            instanceDiv.className = 'alert alert-success d-flex justify-content-between align-items-center mb-2 border border-success border-2';
            instanceDiv.style.cursor = 'pointer';
            instanceDiv.innerHTML = `
                <div onclick="instanceClicked('${setNumber}', '${instance.instance_name}')" style="flex: 1;">
                    <strong>
                        <span class="editable-instance-name" 
                              data-inventory-id="${instance.id}" 
                              data-current-name="${instance.instance_name}"
                              style="cursor: pointer; border-bottom: 1px dashed #28a745;"
                              title="Click to edit name"
                              onclick="event.stopPropagation(); startEditingInstanceName(this)">
                            ${instance.instance_name}
                        </span>
                        <span class="badge bg-success ms-2"><i class="fas fa-check"></i> Selected</span>
                    </strong>
                    <small class="text-muted d-block">Added: ${new Date(instance.added_at).toLocaleDateString()}</small>
                </div>
                <div class="btn-group" role="group">
                    <button class="btn btn-outline-danger btn-sm" onclick="event.stopPropagation(); deleteSetInstance(${instance.id}, '${instance.instance_name}')">
                        <i class="fas fa-trash"></i> Delete
                    </button>
                </div>
            `;
        } else {
            instanceDiv.className = 'alert alert-primary d-flex justify-content-between align-items-center mb-2';
            instanceDiv.style.cursor = 'pointer';
            instanceDiv.innerHTML = `
                <div onclick="instanceClicked('${setNumber}', '${instance.instance_name}')" style="flex: 1;">
                    <strong>
                        <span class="editable-instance-name" 
                              data-inventory-id="${instance.id}" 
                              data-current-name="${instance.instance_name}"
                              style="cursor: pointer; border-bottom: 1px dashed #007bff;"
                              title="Click to edit name"
                              onclick="event.stopPropagation(); startEditingInstanceName(this)">
                            ${instance.instance_name}
                        </span>
                    </strong>
                    <small class="text-muted d-block">Added: ${new Date(instance.added_at).toLocaleDateString()}</small>
                </div>
                <div class="btn-group" role="group">
                    <button class="btn btn-danger btn-sm" onclick="event.stopPropagation(); deleteSetInstance(${instance.id}, '${instance.instance_name}')">
                        <i class="fas fa-trash"></i> Delete
                    </button>
                </div>
            `;
        }
        
        instanceSelectionList.appendChild(instanceDiv);
    });
    
    // Update instance items for keyboard navigation
    // updateInstanceItems();
}

function updateInstanceSelectionDisplay(setNumber, selectedInstanceName) {
    const instanceSelectionList = document.getElementById('instanceSelectionList');
    const instanceDivs = instanceSelectionList.querySelectorAll('div[onclick*="instanceClicked"]');
    
    instanceDivs.forEach(instanceDiv => {
        const parentDiv = instanceDiv.closest('.alert');
        const instanceName = instanceDiv.onclick.toString().match(/'([^']+)'\)/)[1];
        
        if (instanceName === selectedInstanceName) {
            // Update to selected styling
            parentDiv.className = 'alert alert-success d-flex justify-content-between align-items-center mb-2 border border-success border-2';
            const strongElement = instanceDiv.querySelector('strong');
            if (strongElement && !strongElement.innerHTML.includes('Selected')) {
                // Preserve the editable span structure
                const editableSpan = strongElement.querySelector('.editable-instance-name');
                if (editableSpan) {
                    strongElement.innerHTML = `
                        <span class="editable-instance-name" 
                              data-inventory-id="${editableSpan.dataset.inventoryId}" 
                              data-current-name="${editableSpan.dataset.currentName}"
                              style="cursor: pointer; border-bottom: 1px dashed #28a745;"
                              title="Click to edit name"
                              onclick="event.stopPropagation(); startEditingInstanceName(this)">
                            ${editableSpan.dataset.currentName}
                        </span>
                        <span class="badge bg-success ms-2"><i class="fas fa-check"></i> Selected</span>
                    `;
                } else {
                    strongElement.innerHTML = `${instanceName} <span class="badge bg-success ms-2"><i class="fas fa-check"></i> Selected</span>`;
                }
            }
        } else {
            // Update to unselected styling
            parentDiv.className = 'alert alert-primary d-flex justify-content-between align-items-center mb-2';
            const strongElement = instanceDiv.querySelector('strong');
            if (strongElement && strongElement.innerHTML.includes('Selected')) {
                // Preserve the editable span structure
                const editableSpan = strongElement.querySelector('.editable-instance-name');
                if (editableSpan) {
                    strongElement.innerHTML = `
                        <span class="editable-instance-name" 
                              data-inventory-id="${editableSpan.dataset.inventoryId}" 
                              data-current-name="${editableSpan.dataset.currentName}"
                              style="cursor: pointer; border-bottom: 1px dashed #007bff;"
                              title="Click to edit name"
                              onclick="event.stopPropagation(); startEditingInstanceName(this)">
                            ${editableSpan.dataset.currentName}
                        </span>
                    `;
                } else {
                    strongElement.innerHTML = instanceName;
                }
            }
        }
    });
}

function removeInstanceFromDisplay(instanceName) {
    const instanceSelectionList = document.getElementById('instanceSelectionList');
    const instanceSelectionText = document.getElementById('instanceSelectionText');
    const instanceDivs = instanceSelectionList.querySelectorAll('div[onclick*="instanceClicked"]');
    
    let deletedInstanceIndex = -1;
    let deletedInstanceDiv = null;
    
    // Find the instance to delete and its index
    instanceDivs.forEach((instanceDiv, index) => {
        const currentInstanceName = instanceDiv.onclick.toString().match(/'([^']+)'\)/)[1];
        
        if (currentInstanceName === instanceName) {
            deletedInstanceIndex = index;
            deletedInstanceDiv = instanceDiv;
        }
    });
    instanceItems.splice(deletedInstanceIndex, 1);
    
    // Check if the deleted instance is currently selected
    const wasCurrentlySelected = currentlySelectedInstance === instanceName;
    
    // Remove the instance from the DOM
    if (deletedInstanceDiv) {
        const parentDiv = deletedInstanceDiv.closest('.alert');
        parentDiv.remove();
    }
    
    // If the deleted instance was currently selected, select another instance
    if (wasCurrentlySelected) {
        const remainingInstanceDivs = instanceSelectionList.querySelectorAll('div[onclick*="instanceClicked"]');
        
        if (remainingInstanceDivs.length > 0) {
            // Try to select the instance at the same index (below), or the one above if none below
            let targetIndex = deletedInstanceIndex;
            if (targetIndex >= remainingInstanceDivs.length) {
                targetIndex = remainingInstanceDivs.length - 1; // Select the last one (above)
            }
            
            const targetInstanceDiv = remainingInstanceDivs[targetIndex];
            const targetInstanceName = targetInstanceDiv.onclick.toString().match(/'([^']+)'\)/)[1];
            
            // Automatically select the target instance
            selectInstance(currentSetNumber, targetInstanceName);
        } else {
            // No instances left, clear the current selection
            currentlySelectedInstance = null;
            document.getElementById('inventoryContainer').style.display = 'none';
        }
    }
    
    // Check if there are any instances left and update text accordingly
    const remainingInstances = instanceSelectionList.querySelectorAll('.alert');
    if (remainingInstances.length === 0) {
        instanceSelectionText.textContent = 'You don\'t have any instances of this set yet. Add your first instance below:';
        // Reset instance navigation when no instances remain
        resetInstanceNavigation();
    }
}

function addInstanceToDisplay(instance, setNumber) {
    const instanceSelectionList = document.getElementById('instanceSelectionList');
    const instanceSelectionText = document.getElementById('instanceSelectionText');
    
    // Create the new instance div
    const instanceDiv = document.createElement('div');
    instanceDiv.className = 'alert alert-primary d-flex justify-content-between align-items-center mb-2';
    instanceDiv.style.cursor = 'pointer';
    instanceDiv.innerHTML = `
        <div onclick="instanceClicked('${setNumber}', '${instance.instance_name}')" style="flex: 1;">
            <strong>
                <span class="editable-instance-name" 
                      data-inventory-id="${instance.id}" 
                      data-current-name="${instance.instance_name}"
                      style="cursor: pointer; border-bottom: 1px dashed #007bff;"
                      title="Click to edit name"
                      onclick="event.stopPropagation(); startEditingInstanceName(this)">
                    ${instance.instance_name}
                </span>
            </strong>
            <small class="text-muted d-block">Added: ${new Date(instance.added_at).toLocaleDateString()}</small>
        </div>
        <div class="btn-group" role="group">
            <button class="btn btn-danger btn-sm" onclick="event.stopPropagation(); deleteSetInstance(${instance.id}, '${instance.instance_name}')">
                <i class="fas fa-trash"></i> Delete
            </button>
        </div>
    `;
    
    // Add the new instance to the list
    instanceSelectionList.appendChild(instanceDiv);
    
    // Update the descriptive text since we now have instances
    instanceSelectionText.textContent = 'You have existing instances of this set. Choose which one to view or add a new instance:';
    
    // Update instance items for keyboard navigation
    instanceItems.push(instance);
}

function instanceClicked(setNumber, instanceName) {
    navigationInstance = true;
    selectInstance(setNumber, instanceName);
}

function startEditingInstanceName(element) {
    const currentName = element.dataset.currentName;
    const inventoryId = element.dataset.inventoryId;
    
    // Store original content
    const originalContent = element.innerHTML;
    
    // Create input field
    const input = document.createElement('input');
    input.type = 'text';
    input.value = currentName;
    input.className = 'form-control form-control-sm';
    input.style.display = 'inline-block';
    input.style.width = '150px';
    input.style.fontSize = '0.875rem';
    input.style.fontWeight = 'bold';
    
    // Create save button
    const saveBtn = document.createElement('button');
    saveBtn.className = 'btn btn-success btn-sm ms-1';
    saveBtn.innerHTML = '<i class="fas fa-check"></i>';
    saveBtn.style.fontSize = '0.75rem';
    saveBtn.style.padding = '0.25rem 0.5rem';
    
    // Create cancel button
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn btn-secondary btn-sm ms-1';
    cancelBtn.innerHTML = '<i class="fas fa-times"></i>';
    cancelBtn.style.fontSize = '0.75rem';
    cancelBtn.style.padding = '0.25rem 0.5rem';
    
    // Replace content with input and buttons
    element.innerHTML = '';
    element.appendChild(input);
    element.appendChild(saveBtn);
    element.appendChild(cancelBtn);
    
    // Focus the input
    input.focus();
    input.select();
    
    // Save function
    const save = async () => {
        const newName = input.value.trim();
        
        if (newName === currentName) {
            // No change, just cancel
            cancel();
            return;
        }
        
        if (newName.length === 0) {
            showAlert('Name cannot be empty', 'warning');
            input.focus();
            return;
        }
        
        // Check if name is already taken by another instance
        const existingNames = Array.from(document.querySelectorAll('.editable-instance-name'))
            .map(el => el.dataset.currentName)
            .filter(name => name !== currentName);
        
        if (existingNames.includes(newName)) {
            showAlert('An instance with this name already exists', 'warning');
            input.focus();
            return;
        }
        
        try {
            const response = await fetch('/update_inventory_name', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    user_inventory_id: inventoryId,
                    new_name: newName
                })
            });
            
            const data = await response.json();
            
            if (response.ok) {
                // Update the element with new name
                element.innerHTML = newName;
                element.dataset.currentName = newName;
                showAlert('Name updated successfully!', 'success');
                
                // Update the instance name in the global instanceItems array
                const instance = instanceItems.find(inst => inst.id == inventoryId);
                if (instance) {
                    instance.instance_name = newName;
                }
                
                // Update currentlySelectedInstance if this was the selected one
                if (currentlySelectedInstance === currentName) {
                    currentlySelectedInstance = newName;
                }
                
                // Refresh the instances display to update all references
                displayInstances(instanceItems, currentSetNumber);
            } else {
                showAlert(data.error || 'Failed to update name', 'danger');
                cancel();
            }
        } catch (error) {
            console.error('Error updating name:', error);
            showAlert('An error occurred while updating the name', 'danger');
            cancel();
        }
    };
    
    // Cancel function
    const cancel = () => {
        element.innerHTML = originalContent;
    };
    
    // Event listeners
    saveBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        save();
    });
    cancelBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        cancel();
    });
    
    input.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            save();
        } else if (e.key === 'Escape') {
            e.preventDefault();
            cancel();
        }
    });
    
    // Click outside to cancel
    const clickOutside = (e) => {
        if (!element.contains(e.target)) {
            cancel();
            document.removeEventListener('click', clickOutside);
        }
    };
    
    // Add event listener after a short delay to prevent immediate cancellation
    setTimeout(() => {
        document.addEventListener('click', clickOutside);
    }, 100);
}

function showAlert(message, type) {
    // Get or create toast container
    let toastContainer = document.getElementById('toastContainer');
    if (!toastContainer) {
        toastContainer = document.createElement('div');
        toastContainer.id = 'toastContainer';
        toastContainer.className = 'toast-container';
        document.body.appendChild(toastContainer);
    }
    
    // Create toast notification
    const toast = document.createElement('div');
    toast.className = `toast-notification ${type}`;
    
    // Set icon based on type
    let icon = 'fas fa-check-circle';
    switch(type) {
        case 'success':
            icon = 'fas fa-check-circle';
            break;
        case 'danger':
            icon = 'fas fa-exclamation-circle';
            break;
        case 'warning':
            icon = 'fas fa-exclamation-triangle';
            break;
        case 'info':
            icon = 'fas fa-info-circle';
            break;
    }
    
    toast.innerHTML = `
        <div class="toast-content">
            <i class="toast-icon ${icon}"></i>
            <span class="toast-message">${message}</span>
            <button class="toast-close" onclick="this.parentElement.parentElement.remove()">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="toast-progress" style="animation-duration: 3s;"></div>
    `;
    
    // Add to container
    toastContainer.appendChild(toast);
    
    // Auto-dismiss after 3 seconds
    setTimeout(() => {
        if (toast.parentNode) {
            toast.style.animation = 'slideDownOut 0.3s ease-out';
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.remove();
                }
            }, 300);
        }
    }, 3000);
}

async function selectInstance(setNumber, instanceName) {
    // Do nothing if the currently selected instance is clicked
    if (currentlySelectedInstance === instanceName) {
        return;
    }
    
    // If switching to a different instance, hide current inventory first
    if (currentlySelectedInstance && currentlySelectedInstance !== instanceName) {
        hasUnsavedChanges = false;
    }

    // Set the current instance index for arrow key navigation
    // updateInstanceItems();
    currentInstanceIndex = instanceItems.findIndex(item => item.instance_name === instanceName);
    
    // Set current instance for inventory modifications
    currentInstanceName = instanceName;
    currentlySelectedInstance = instanceName;
    
    // Update the instance selection display to show the selected instance
    updateInstanceSelectionDisplay(setNumber, instanceName);
    
    try {
        const response = await fetch('/view_instance_inventory', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                set_number: setNumber,
                instance_name: instanceName
            })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            // Load and display inventory with instance-specific modifications
            await loadModifiedInventory(setNumber, instanceName);
            displayInventory(data.inventory);
        } else {
            showAlert(data.error || 'Failed to load instance inventory', 'danger');
        }
    } catch (error) {
        console.error('Error selecting instance:', error);
        showAlert('An error occurred while loading the instance', 'danger');
    } finally {
    }
}


function showInstanceSelectionScreen() {
    // Hide inventory and show instance selection
    document.getElementById('inventoryContainer').style.display = 'none';
    document.getElementById('instanceSelectionSection').style.display = 'block';
}

async function addNewInstance() {
    const setNumber = currentSetNumber;
    const setTitle = document.getElementById('setTitle').textContent.replace(' Set Information', '').replace(' ', '');
    let instanceName = document.getElementById('newInstanceName').value.trim();
    
    if (!instanceName) {
        showAlert('Please enter an instance name', 'warning');
        return;
    }
    
    if (!setNumber) {
        showAlert('No set selected', 'error');
        return;
    }
    
    // Get existing instances to check for duplicates
    const existingInstances = await getInstances(setNumber);
    const existingNames = existingInstances.map(instance => instance.instance_name);
    
    // Generate a unique name if the current name already exists
    const originalName = instanceName;
    while (existingNames.includes(instanceName)) {
        const lastChar = instanceName.slice(-1);
        if (/\d/.test(lastChar)) {
            // Last character is a digit, increment it
            const baseName = instanceName.slice(0, -1);
            const lastDigit = parseInt(lastChar);
            instanceName = baseName + (lastDigit + 1);
        } else {
            // Last character is not a digit, add "0" to the end
            instanceName = instanceName + '0';
        }
    }
    
    // Update the input field if the name was changed
    if (instanceName !== originalName) {
        document.getElementById('newInstanceName').value = instanceName;
        showAlert(`Instance name changed to "${instanceName}" to avoid duplicate`, 'info');
    }
    
    try {
        const response = await fetch('/add_to_collection', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                set_number: setNumber,
                set_name: setTitle,
                instance_name: instanceName
            })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            showAlert('New set instance added successfully!', 'success');
            
            // Add the new instance to the display
            const newInstance = {
                id: data.owned_set_id,
                instance_name: instanceName,
                added_at: new Date().toISOString()
            };
            addInstanceToDisplay(newInstance, setNumber);
            
            // Automatically select the newly added instance
            await selectInstance(setNumber, instanceName);
            
        } else {
            if (data.login_required) {
                showAlert('Please log in to add sets to your collection', 'warning');
                // Optionally redirect to login page
                setTimeout(() => {
                    window.location.href = '/login';
                }, 2000);
            } else {
                showAlertNear(data.error || 'Failed to add set to collection', 'danger', '#instanceSelectionSection');
            }
        }
    } catch (error) {
        console.error('Error adding to collection:', error);
        showAlertNear('An error occurred while adding to collection', 'danger', '#instanceSelectionSection');
    }
}


function viewInstance(setNumber, instanceName) {
    // For now, just show an alert. In the future, this could open a modal or navigate to a specific view
    showAlert(`Viewing instance: ${instanceName} of set ${setNumber}`, 'info');
}

async function deleteSetInstance(owned_set_id, instanceName) {
    // Check if user has chosen to skip confirmation
    if (!shouldSkipDeleteConfirmation()) {
        const confirmed = await showDeleteConfirmation(instanceName, 'This will also delete all inventory modifications for this instance.');
        if (!confirmed) {
            return;
        }
    }
    
    try {
        const response = await fetch('/delete_set_instance', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                owned_set_id: owned_set_id
            })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            showAlert('Set instance deleted successfully!', 'success');
            
            // Check if the deleted instance was the currently viewed one
            // const deletedInstanceName = instanceName;
            // if (currentlySelectedInstance === deletedInstanceName) {
            //     // Hide inventory and reset selection
            //     document.getElementById('inventoryContainer').style.display = 'none';
            //     currentlySelectedInstance = null;
            //     currentInstanceName = 'Default';
            //     hasUnsavedChanges = false;
            // }
            
            // Remove the deleted instance from the DOM
            removeInstanceFromDisplay(instanceName);
        } else {
            showAlert(data.error || 'Failed to delete set instance', 'danger');
        }
    } catch (error) {
        console.error('Error deleting set instance:', error);
        showAlert('An error occurred while deleting the set instance', 'danger');
    }
}


async function saveInventory() {
    if (!hasUnsavedChanges) {
        showAlert('No changes to save', 'info');
        return;
    }
    
    console.log('Saving inventory with data:', {
        set_number: currentSetNumber,
        instance_name: currentInstanceName,
        modifications: modifiedInventory
    });
    
    try {
        const response = await fetch('/update_inventory', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                set_number: currentSetNumber,
                instance_name: currentInstanceName,
                modifications: modifiedInventory
            })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            showAlert('Inventory saved successfully!', 'success');
            hasUnsavedChanges = false;
            // Hide the save button
            document.getElementById('saveInventoryBtn').style.display = 'none';
        } else {
            showAlert(data.error || 'Failed to save inventory', 'danger');
        }
    } catch (error) {
        console.error('Error saving inventory:', error);
        showAlert('An error occurred while saving inventory', 'danger');
    }
}

// Initialize instruction cache when page loads
loadInstructionCache();
</script>
{% endblock %}
